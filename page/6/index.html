<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Summer Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Summer Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Summer Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Summer Blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Summer Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Summer Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-节日" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/22/节日/" class="article-date">
  <time datetime="2016-12-22T11:09:35.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/节日/">节日</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font face="黑体" size="3.5" color="#696969">&nbsp;&nbsp;独在异乡为异客,每逢佳节倍思亲;遥知兄弟登高处,遍插茱萸少一人。在国人心中，传统的节日往往意味着团圆和相聚，最近的一次和家人们相聚是外公的葬礼，短短相见后又是长久的别离。<br><br> &nbsp;&nbsp;小的时候，特别盼望过年，因为过年的时候大人们能够停下来围在一起打打麻将，能收到红包还能穿着新衣裳和兄弟姐妹们满街乱跑。我的所有关于新年的回忆到初三那年基本就停止了，往后的日子里自己仍然会特别期盼春节，可因为一些原因，大学之前的所有回忆里面，有很长一段是自己不想面对，不想承认也不想提起的，因为那里有太多的泪水，委屈，和疑问。看到一段话：当你遇到困难时，不要想着找别人说，因为它们会觉得你在抱怨；寻求安慰也无济于事，还徒增了别人的烦恼，而当你独自走过艰难险阻，一定会感谢当时一声不吭咬牙坚持的自己。以此共勉。<br><br> &nbsp;&nbsp;昨天冬至，二十四节气里面的最后一个节气，意味着这一年的结束和新一年的到来；冬至到，吃水饺；所有卖水饺的店，人多的出奇。自己买了一包速冻三鲜馅水饺沾沾节日的喜气，一个人煮的饺子，一个人吃，吃起来竟别有味道。<br><br>&nbsp;&nbsp;12.24是外国人的平安夜，第一次知道平安夜这个东西是初中，班里的女同学都在争相收集别人喜欢的明星，然后送出海报，最后大家比一比谁收的海报最多，最好。初中，我剃了精神的平头，短头发能让自己看起来更帅气；学习成绩不突出，常常需要老妈到老师家走动走动才不至于被分到班级的最后一桌，成绩不好，可是心气还挺高，总喜欢和班里学习好的同学混在一起。每每想到这些，自己就会想到初中时候那个家境优越，成绩突出，长相甜美的我的当时的好朋友，暂时称她为L。我觉得我这个人特别奇怪，初中时候就学会了吃醋，L每次和其他同学走在一起，自己会生气的不行；初中的时候，大家都追求特立独行，班上好多女同学都去偷偷地染发，L也想去，中午放学一起回家，我对他说如果她和X一起去染头发，回来我们就绝交。下午，阳光甚好，透过阳光看见L头上好像闪着紫色的光亮，然后那一天我都没有主动去和她说话；第二天，她向我道歉，我心里居然满满的骄傲。L成绩好，追求的男孩子也很多，我在她身边就像红花旁边的绿叶，除了衬托还是衬托。可我还是乐此不疲的喜欢和她待在一起，好像多呆一段时间就能够让自己也吸收她身上的灵气。为了吸引她的注意，初中毕业照自己谎称发烧，没有去照，私心想着她会打电话来问问我没什么没有去。最后，电话真的来了，可是我们的初中毕业照却再也不能补照，我的最美好而且幸福的初中生活在遗憾中结束了。她考上了重点高中，而我差了好几十分，因为不能日日再见L，自己常常难过的想哭。再后来，我转了学，L成了生命里永远的过客，最后一次见她还是在初三某一天。我和我的L走散了，我和我自己也走散了。<br><br>&nbsp;&nbsp;听别人说，L现在过得特别好。还是像从前一样，总是能够成为众人眼里的焦点。生活富足，家庭美满。生活里面越来越多的遗憾，如果有一天，你还记得我，希望我们能够在这茫茫人海中重逢，温一温少年的暖；如果下辈子我还记得你，希望还能和你做朋友。<br><br>&nbsp;&nbsp;圣诞要到了，自己提醒远在内蒙出差的先生，该送我一份礼物，并且限定一堆范围，向来木讷的先生被自己的要求好生为难。最后他用我的账号送我一份我指定的单向历，然后由他付款。和先生特别像，我们都是随时爆炸的火药桶，不过他很体贴，每次爆炸现场都是他来收场:-D，恋爱几年，从没过过特定的节日，还常常忘记自己的生日，但却每天都会像是过年，能包容我很多缺点，体贴的像个女人，反而是我经常不修边幅像个粗犷的男人。古人说，塞翁失马焉知非福；失去的会以另外的形式得到。<br><br>&nbsp;&nbsp;我们都一样，总是想要安慰，却又不想放弃理想；总是渴望金钱，却有逃避人情；人自古矛盾。国外有个人，对这样的矛盾心理，给出了一个可行的解决办法：将每日的生活分成对半，一半需要继续完成不想做却能够保证生活开支的工作，一半去追求心里的艺术；既不能让重复的工作霸占所有时间，也不能让艺术填充所有生活。俩者要相辅相成，要为自己追求的艺术做相应的投资，去参加高级的培训，去完善个人所爱的艺术体系，将艺术打造成个人品牌；同事时好好工作，在艺术不能支撑开支时候，用稳定的收入去弥补这些不足。我觉得他的这个建议特别合适，但需要找一个好的实施办法。那位朋友还建议我们多出去开拓个人视野，丰富阅历之后对所思所想会有不一样的看法。看来有些问题是全球都有的，不只是急躁的年轻中国朋友。</font>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/22/节日/" data-id="ciznrq45i001feouxto4aniyw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-小插曲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/22/小插曲/" class="article-date">
  <time datetime="2016-12-22T01:51:38.000Z" itemprop="datePublished">2016-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/22/小插曲/">小插曲</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font face="黑体" size="3.5" color="#696969">&nbsp;&nbsp;一天阅读的文字摄入量不能支撑自己每天2000字的量,写东西的时候,经常会觉得所学太少, 肚子里面的存量都不够撑下来这么一个星期的文章。书都读到哪里去了￣へ￣<br><br>&nbsp;&nbsp;每到年底的时候，会有好多文章提醒你今年的目标又没完成，明年的计划该怎么写。年年岁岁花相似，岁岁年年人不同；相似的文章每年都能吸引到我这种目标感弱的人流量，刚看的前俩个小时，血槽加满，热情高涨的计划着下一年该做些什么事，应该完成哪些目标，次年年末又回到这样的轮回里面。<br>&nbsp;&nbsp;女生一般在13，4岁以后会有个好朋友，每个月来访一次，可劲的让你疼。她不来，胆战心惊；她来了，战战兢兢。我的好朋友这个月闹了点小情绪，没有按时来访，也不知道是哪里没有照顾周全。急得人又是查资料，又是买药，再加上连续几天的腹泻和干呕，厮以为有个小生命要来这个世界了，上午还在和他爸爸讨论该给他起个什么名字好，下午早孕纸上的一条红线就把人打回原形，看来小东西没给我这么早当妈妈的机会。昨天夜里临睡前，胃里翻酸水，好折腾，又紧张有害怕，没有做好为人母的准备，更重要的是猫怎么办？他会不会一出生要跟我抢东西吃，还会占用自己的睡眠时间和娱乐时间，还能夺走身边所有人的爱。可是如果他真来了，还没做体检怎么办，他会不会携带了病原体？前俩天还吃了退烧药，不会致傻吧，我已经够傻了，生个傻姑娘，将来我和他爸爸谁来养？想了好多好多问题以后，大脑可能是对于我所有的无知假设进入了疲惫期，晕乎乎的睡着了。所谓养儿方知父母恩，妈妈当时一定经历了很多很多，感谢她把自己养育这么大。<br><br>&nbsp;&nbsp;前些时间，公司因为图片侵权被其他公司告发，不知道有没有对簿公堂；对于所有公司能用钱解决的事情应该都不想多生枝节吧。可是在对责任人处理这件事上，有点疑惑，因为那个姑娘在某一个下雨天自己浑身没有一件干净衣服时慷慨借给自己过一双鞋；虽然鞋子没有穿，我们也没有太多交集；可至那以后，自己心里对她总是怀有一些感激。第一天来公司报道的时候，自己对着重重的台式机满头大汗的弄了俩个多小时，从搭环境到要地址，没有一个人说伸出一个手帮帮忙，也正是因为工作以后习惯了一个人处理问题，即便是遇到了不知道应该怎么吐槽的委屈时候，还是会默默地一个人扛下来。很多人应该和我一样，才会慢慢地，大家都不善言辞，端坐在格子间里面做安静的螺丝钉。直到因为这件事，她被辞退了。她什么时候离开的，走了有多久自己一概不知。可听说她走了，心里面会很遗憾。 我问自己，如果自己是领导，这件事应该怎么做？已经为对方公司支付了版权费用，还需要将责任人赶走么。是不是自己视野太窄，公司这样做其实为了以儆效尤。<br>&nbsp;&nbsp;人在不同位置，决定也会不同，先生白天发了一张截图，截图内容是项目经理和部门助理关于某个员工的考勤情况记录。先生说这位经理做法欠妥帖，没有考虑员工天天加班至深夜。作为一名旁观者，我跟他讨论了一下这位经理的尴尬。由于项目预估时间与开发时间严重不符，项目迟迟不能上线，客户三番五次的发火，开发进度仍然滞后，开发人员苦不堪言，长期的加班使得同事们怨声载道，而客户压力又使得这位经理进退两难。我跟先生说，其实经理才是压力最大的，让他少参与讨论，每个人所处位置不一样，看问题的角度和方式方法也会有很大的差异。先生没说话，可能是忙，也可能是看我站着说话不腰疼。这样的问题，会不会有一个像明代徽州府处理歙县多出来的人丁私绢的俩全其美的办法呢？能够安抚所有疲惫的同事，也能宽慰疲惫的中间领导。<br>&nbsp;&nbsp;互联网发展起来，所有东西都讲求快，快点出项目，快点讲故事，快点拿到投资；楼市也快速发展，一年能涨几十万；辛苦工作一整年，没有楼房一月涨得快。有人开玩笑说，当下时代最亏的是拿买房的钱去创业。好多年轻人（包括我自己）举全家之力想凑一个4，50十平米的首付，哪还有人谈什么梦想。<br><br>&nbsp;&nbsp;懂了那么多道理，还是不能过好这一生。<br>&nbsp;&nbsp;前段时间，上映了一部电影《七月与安生》，影片中出演女主演的马思纯和周冬雨俩位80后演员一起获得了这一届金马奖影后，一时间，网络上多了很多整篇整篇关于俩位女主身份的报道。周冬雨：谋女郎，出道于《山楂树之恋》，凭借其清纯可人的形象获得大众的喜爱；马思纯：其母是蒋雯丽的经纪人，从小跟着妈妈跑剧场，起点也是特别高。别问我金马奖是啥，我估计应该和数学界的奥数冠军差不多吧，或者更高一些？具体多牛X，请移步至Google。恰好听过别人推荐，为了看这部片子自己还特意买了腾讯视频的会员。影片确实很好看，当然了我这种级别的其实也分不出到底啥水准，画面好看，人物表演不做作，故事能吸引人，我便会给它们打高分，所以我的观后感没什么参考意义。这部有些文艺的电影集合了第三者，劈腿，怀孕所有狗血剧情应该有的元素，难得的是这部电影让这些狗血串在一起都还能够让人不反感。七月与安生，是俩个从小一起长大的好伙伴，和大多数女生幻想的一样，她们无话不谈。安生出生在一个父母恩爱，家境良好的家庭，而七月自小父母离异，常常去安生家蹭饭。安生文静，乖巧；七月，调皮，捣蛋。影片一开始，俩个人的点点滴滴都有很强的反差，高中的时候俩个人爱上了同一个帅哥。而帅哥又阴差阳错的和安生在一起，心里始终住着七月。最后她们都选择了友情，七月说：“即使重新选一次，她还是会选择安生。”，安生为了七月在新婚现场选择了离开。最后的最后安生过成了七月，七月过上了安生。影片让人产生共鸣的是，大多数女生心里都有一个林七月，她们都希望自己是那个李安生，也是大多数女生在工作以后丢了那个林七月，然后一直寻找着自己的安生。</font>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/22/小插曲/" data-id="ciznrq43c000teoux88difhlc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-显微镜下的大明" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/20/显微镜下的大明/" class="article-date">
  <time datetime="2016-12-20T12:45:48.000Z" itemprop="datePublished">2016-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/显微镜下的大明/">显微镜下的大明</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font face="黑体" size="3.5" color="#F08080">你会去菜市场买珠宝么?</font>

</blockquote>
<h3 id="一个学霸一起的一场骚乱"><a href="#一个学霸一起的一场骚乱" class="headerlink" title="一个学霸一起的一场骚乱"></a><font face="黑体" size="4.0" color="#B96969">一个学霸一起的一场骚乱</font></h3><font face="黑体" size="3.5" color="#696969">&nbsp;&nbsp;马先生妙笔生花的文章将明代一件小事以诙谐幽默的方式阐述出来,从小人物帅嘉谟入手讲述了万历年间的一件看似很小却牵涉了当朝首辅张居正的故事。明代徽州府地处广西、浙江、福建交界的位置，其下共有6个县：绩溪、婺源、休宁、黔县、歙县、祁安。徽州府也就是现在黄山所处位置。<br> &nbsp;&nbsp;帅嘉谟是一位数学非常好，但在明代却没有太大用武之地之人，他的数学好到什么程度呢？大概是，放在今天分分钟拿下奥数的水平。看来无论什么时代，学霸都是一种不一样的存在。可惜他的聪明才智在古代主要能够发挥用途的地方只有粮库库管一类地方。有一天实在无聊，恰好其所在歙县存有整个徽州府的文件，对于我们枯燥的账簿，变成了他解闷的好去处。然后某一天，他发现歙县比其它五县多出一项人均绢税的奇怪税负，经过各种资料的查阅，最终发现该税负为歙县承担了本应为所有各县按人头平均的税项。他将自己的各项计算整理为有利证据越级递交给南京户部，后经过层层批示，最终减轻了歙县人民税负，自己却沦为阶下囚，发配充军。小故事往往能映射出一个时代，无论什么时候，利益相关者总是相互维护的。</font>

<h3 id="在北京"><a href="#在北京" class="headerlink" title="在北京"></a><font face="黑体" size="4.0" color="#B96969">在北京</font></h3> <font face="黑体" size="3.5" color="#696969">&nbsp;&nbsp;这俩天的北京，被雾霾笼罩，朋友圈应景的各类雾霾文章层出不穷。前段时间自己一直在想，是不是应该离开北京？为什么自己始终过着自己不喜欢的生活，自己想要的生活是什么样的？曾经以为，一辆越野副驾坐着帅气的拉布拉多，和我一起驰骋在沙漠里面是向往所在。自己谷歌了一下别人关于是否要逃离北上广给出的答案，其中一篇没有做出回复，却用了大量的数据证实，现在能够做选择的我们想比下一代有多幸福。文章给出了许多数据，包括近几年国内各个省份人口的净流入情况，算下来，大概在2050年除了北京、江苏、广东、浙江、上海这些资源大省外，劳动力资源会进入严重的负增长。专家估算，中国的人口到2050年，人口老龄化趋势严重，放开二胎政策能够将趋势缓解；又有专家说，即使去掉中国的计生办，未来人口老龄化问题也不能得到有效改善。有一天我们会像日本一样，大阪和东京的都市圈繁荣依旧，周围的村庄和城市却在不断衰败，小城镇的人民不得不抛弃家乡加入到大都市的生活。哪种说法，都在警告我们，未来的竞争会更激烈。<br><br>&nbsp;&nbsp;我出生的地方是个边陲小镇，那里依山傍水，鸟语花香。小的时候，小镇里的孩子最向往的是离开家乡，去到更大的地方。长大后，出了那个小镇，而小镇成了一辈子最想回去的地方。我常常问自己，如果能够重新选择一次，毕业以后我回去哪里？北京有丰富的教育资源，完善的医疗资源，有各行各业的人才和精英，北京属于所有人，而所有人又不属于北京。刚才出门取外卖，每一个人都戴着口罩相互问好，觉得很奇怪。我们承受着比小城市更大的压力，也享受着比小城市更不清新的空气。可为什么这个人人都向往的首都，会变成一片霾境？<br><br>&nbsp;&nbsp;初来北京时，觉得一起都那么新鲜。这里的夜晚永远明亮，这里的街道永远干净。住在6个人一间的房间，心里面还是觉得赚了。那个时候总想要再节省一点，能走路绝不打车，可身体还是很好；现在能打车绝不走路，可还是经常生病。我还记得自己一个人坐在床上，想着这么大的城市，有一天一定会有自己立足之地，心里面特别骄傲。每周都去一次书店，和小朋友们抢漫画看。第一次去北戴河，出海的时候同行的人租了一条渔船，他们都紧紧地抓着船圩，我一个人站在船头没有任何保护措施，不觉得害怕，还觉得海好美。后来，稍微能负担起更多的房租，搬出来独住。每年的房租好贵啊，而且一年比一年价高。自己在房租后面拼命地追啊追，好像北京要把人抛弃了一样。可能我跑的还是太慢，不然怎么会总也追不上。</font>

<h3 id="猫"><a href="#猫" class="headerlink" title="猫"></a><font face="黑体" size="4.0" color="#B96969">猫</font></h3> <font face="黑体" size="3.5" color="#696969">&nbsp;&nbsp;活得时间长了，会更羡慕家里的猫。没养猫之前，总听到身边人说，猫不是忠臣，它不会忠于主人。养猫之后，会越来越想多和家里的猫待在一起。我家的猫没有名贵的品种，也没有嗲嗲的声音，只是因为相处了很久，会越来越依赖于它的存在。它不是不忠，只是喜欢独处。相比狗而言，猫的独立常常会令主人没有存在感。我家是只三花猫，虽然比刚来家里面时候调皮了很多，辜负了当时取名为’安安’，可特别令人喜欢。每逢过节，离开北京要把它送去寄养的前俩日，自己都会觉得空落落的，因为没有它对你叫了，打开门也没有毛茸茸的一团站在鞋柜上喵喵的向你求抱。猫嗜睡，阳光充足的午后，沙发是它的好伙伴，起初是蜷在一区，后来是仰着肚皮。研究表明，向你漏肚皮，表示它对你卸下了所有装备；研究还说，它从喉咙里面发出的呼噜声表示它很开心。可我家的猫几乎没有不呼噜的时候，妈妈刚来家里时候，以为它支气管生了病:-D。吃饭的时候，如果桌子旁边有位置，它会呆呆的坐在上面，乖乖的看着我们吃饭，卖萌无罪。它精神的时候，所到之处一片荒芜，无论是鲜花还是绿叶统统是肉爪需要征服的疆土；它寂寞的时候，会趴在你的身边，用下巴蹭你的手。它很聪明，做了坏事，知道犯错误会迅速逃离犯罪现场；如果不能幸运离开，它会耍赖团在你脚边撒娇打滚。<br>&nbsp;&nbsp;养猫真是有很多欢乐，要是能有人解决掉毛这个世纪难题，我会把家里变成猫舍。随时享受主子们带来的温暖，说起来，自己还真是应该跟它好好说说感谢，谢谢它在所有没人的时间对自己的陪伴，谢谢它没有记住我对它的所有打骂教训。养猫如此，有个人陪伴更应该好好感激。</font>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/20/显微镜下的大明/" data-id="ciznrq43s000xeouxm3f9xs17" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-习惯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/20/习惯/" class="article-date">
  <time datetime="2016-12-20T01:49:50.000Z" itemprop="datePublished">2016-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/习惯/">习惯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">自己写东西的时候，如果妈妈在旁边放电视，会戴上耳机尽量让音乐声音超过电视剧；可是一个人在家，房间里面冷冷清清，不会被任何人打扰的时候还是会听音乐。前者叫做甜蜜的负担，后者称为孤单的狂欢。</font>

</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a><font color="#B96969" size="5.0" face="黑体">1.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;这是想要坚持下来的第四天，为了写文字的时候不只胡乱看文章凑字数，在家到地铁这段路上看了一些现在比较流行的内容APP上作者的文章，然后自己有一点迷茫。别人是怎么一气呵成的写出不粘不腻清爽干净的文章呢，还能够吸引读者继续读下去，并且在读完之后若有所思？有一天，希望我也能成为这样的作者，不为这个世界的千千万万，只为那个被我吸引的你，哪怕这样的人只有一个。<br><br>&nbsp;&nbsp;前俩天有个很火的宣传，&lt;得到&gt;APP付费10万购买知名大V马伯庸的一篇文章，免费在应用上让读者看，只是拟定了一份好像不是很严肃的协议，希望看到马的文章的朋友们“仗义”相助，将应用分享给身边5个人。与平时造势营销不一样的地方在于，这一次的得到团队的营销不仅仅没有引起大家的反感，反而很积极地去分享和传播。互联网带来的便利的同时，也带来了爆炸的信息，我们每天好像很繁忙的浏览于不同的软件之间关心国家大事，国际要闻。可是一个转身，便会忘记上一秒的记忆。时间被分成了无数个碎片，好像很勤奋的在吸收营养，到最后只是呼吸了一肚子雾霾。明星们一个又一个不断刷新底限的炒作，让人觉得疲惫，平时寡言少语的我们在屏幕另一端看见各种明星的八卦时候，所有的道德都展现出来了，是德行不好的人都不上网还是上网的人都有优良品德？<br><br>&nbsp;&nbsp;马先生的那篇文章在被得到购买版权之前，有一段小故事。他老人家的&lt;显微镜下的大明&gt;之前一直在网上连载，先生寻经考据查阅了很多相关的历史书籍和资料，最终才完成了那篇3万字左右的文章。完成文章耗费了不少的时间，可由于文字数不多不少、不上不下不能作为单独的书籍出版，又不能单独查阅，所以先生也只是将文章放在网上任其自由生长。这件事被’和菜头’知道后，大为恼火，他认为这样优秀的文章不应该被埋没，并认为应该有人为他付费。他让先生将网络上的文章删除，并愿意为先生找到购买版权的人，于是有了后面的事。<br><br> &nbsp;&nbsp;我特别赞同’和菜头’的做法，而且也愿意为好的知识付费，不仅对于作者的尊重也是对自己的付出点赞。如果越来越多的读者和作家能意识到知识产权的重要性，一定会有更多的优秀文章被大众熟知。这一点，在我们这代身上，已经有了很好的改正，已经能够看到知识创业在当下的可行性。好东西应当光芒万丈。</font>

<h3 id="2"><a href="#2" class="headerlink" title="2."></a><font color="#B96969" size="5.0" face="黑体">2.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;良好的知识体系跟从小养成的学习习惯息息相关。好多学霸，学东西能够一通百通，自成一家；而很多像我一样的学渣，理解问题像是掰玉米的狗熊，掰一半丢一半。可又因为习惯的养成往往是反人性的，大脑不愿意主动回忆起这些东西，比起买买买的爽，学习新知识简直是个灾难。有国外的同学帮我们找到了好的顺应大脑舒适区的办法，让习惯的养成变得简单一点。《习惯的力量》里面说好习惯难继续执行，是因为人们往往在刚开始做的时候，设定了太高的门槛，比如要一个月瘦20斤，每天游泳一小时，一个月英语过专八等；如果能够把目标变得简单易行，随手可做，那么会很容易坚持，将一个月瘦20斤调整为每天5个俯卧撑，每天游泳一小时改为一天跑步一公里，1年以后会有意想不到的成就，作者称他们为微习惯。<br><br>&nbsp;&nbsp;提到微习惯，网上有很多人将扎克伯格的个人计划作为例子：2011年，每天扎领带上班；2014年学习汉语，于是每天和中国员工交谈，2015年时候已经能够用汉语演讲；每天想想身边令自己感动得事，其中他对妻子的感谢视频尤其令人感动；2015年，要恢复每天写代码的日子；每周读一本书，在年底时，Facebook上他一共推荐了22本书；（时间和计划可能有出入，后面看到准确的列表重新更新）等等。很多人在看到他的计划时候时，可能都会觉得不屑于去做，这也是需要我们反思的地方。<br><br>&nbsp;&nbsp; 想想自己每年的计划，简单粗糙，可操作性不强。今年要去旅游，要会化妆，要看7本书，要完XX指标。年末数列表，这些计划好像都完成了，可是又好像没完成，没有丝毫的成就感。17年将至，新年的计划要求和扎扎的一样明确也是有难度，可还是要向他们看齐么。把学会化妆改为学会化自然清透的裸妆，每周至少有2天是带妆出门的；看7本书换成每俩周看一本书，在书上对值得反复回味的地方做出标记，方便下次阅读。能够在几分钟之内解决的事情，不要记在todolist上面始终占用大脑的内存空间，大脑容量有限，始终记得一件没有完成的时会占用资源，使其不能得到合理利用和释放。</font>

<h3 id="3"><a href="#3" class="headerlink" title="3."></a><font color="#B96969" size="5.0" face="黑体">3.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp; 说来惭愧，文中提到的《显微镜下的大明》和《习惯的力量》自己都还没有看过，明天先把’大明’看了，在对先生的文章写出读后感悟。这样只是看了别人的总结实行拿来主义，不是个好行为，对于文章里面出现的内容应当是自己仔细查阅过得才能够写出来，这才是对文章负责。</font>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/20/习惯/" data-id="ciznrq42h000beouxkofan4s1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-生活在别处" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/19/生活在别处/" class="article-date">
  <time datetime="2016-12-19T02:25:48.000Z" itemprop="datePublished">2016-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/生活在别处/">生活在别处</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">小的时候听大人们说谁家的小孩又乖又聪明，学习好，品质好；长大以后看别人的朋友圈经常能看见好车好房好身材，没有工作压力，没有经济拮据；我们的向往的生活永远在别的地方。</font>

</blockquote>
<h3 id="怎么理财"><a href="#怎么理财" class="headerlink" title="怎么理财"></a><font color="#B96969" size="4.0" face="黑体">怎么理财</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;理财类的初级入门读物上都说：你不理财，财不理你。报着让财理自己的端正态度，阳光还不错的周日早晨听了简七的极简理财课。对我这样一窍不通的菜鸟级新人，虽然老师的课讲得通俗易懂，但对于我自己可操作的内容有限。课程中提到了俩个概念，算是给自己在以后的道路上打个基础。课程中老师做了个例子：用5w投资，2005年开始进行资产配置，每年重新对资产分配保证资产的动态平衡，用数据回测的方式在其2015年10年时间里面刨去汇率和手续费等等因素，15年的投资金额会变为19w。虽然只是数据回测的方式模拟了10年的交易，及时在真实操作中也是可行的。可惜自己除了没有股票账户，也没有多余的时间和精力进行这样的配置尝试。<br><br>&nbsp;&nbsp;之前也关注了其他的公众号和关于理财的课程等，不知道是什么原因，总不能将理财这个东西完全跟自己的生活完全做个关联，看来时候还没到。前段时间家人生病，让自己对保险多用了好几分心思。对于一个普通家庭，即使有医疗保险作为保障，大病面前还是觉得无奈和苍白，经济快速发展的同时，国民素质也在不断下降。不断爆出的食品安全问题，让人早已见怪不怪，我们开始关注的从什么不能吃，变成了什么可以吃。黄瓜上的黄花要用药水泡，才能在出售给来百姓时候卖个好的价钱；牛肉用化学黏合剂黏在一起，以次充好；三聚氰胺提高婴幼儿奶粉中的蛋白质含量等等。<br><br>&nbsp;&nbsp;树欲静而风不止，子欲养而亲不待。我们忙着赚钱，忙着生活，到了能够享福的年龄却还要忙着生病。疾病总是最公平，无阶级，无权贵。重疾面前人人难逃一死。应运而生的重疾保险也在最近几年里面火了起来。作为一个怕死的人，刚知道这种保险的时候，有点小兴奋，而作为一种长期的保险，这个险种的保费动辄10几万。关注了好一段时间都没有买，因为不懂也不知道意义究竟有多大。看了一份简七推荐的保险清单，里面详尽的介绍了各个年龄层需要购买的险种，看完受益良多。人这一辈子想要保全自己，需要的保险至少要7份，前路任重而道远。</font>

<h3 id="请你原谅我"><a href="#请你原谅我" class="headerlink" title="请你原谅我"></a><font color="#B96969" size="4.0" face="黑体">请你原谅我</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;情感类节目中，用亲情和故事总能赚足观众的眼球，每次看到这样的节目，我的小金豆啪嗒啪嗒的跟着主人公的心痛而动。一位父亲满含泪水希望读懂儿子心里的想法，儿子5岁时候，由于夫妻感情破裂，选择了各奔东西，还在幼儿园的儿子被母亲没有任何通知的前提下带走，一别11年，再相见，父子难回从前；儿子喜欢网游，宁愿坐在电脑前和’战友’征途新世界，都不想抬头看老爸一眼；爸爸满心愧疚的对儿子告白，儿子却只是冷冷的看着。<br>&nbsp;&nbsp;幸福的家庭是相似的，而不幸的家庭各有各的不幸。父母不负责任的决定，受伤的却总是无辜的孩子。童年缺失的爱长大以后能够弥补么？还好，儿子只是不想跟别人说话，心里能暖起来的。过去的一些不开心经常会随着时间一起成长，他们从来不会消失不见，只是我们学会了怎样去更好的和它共处。儿子说：“我能理解你心里的想法，知道你想做什么；但对于我来说，我觉得你是我爸这就足够了。对于我来说你只是个不太熟悉的陌生人，你不能因为称你为父亲，就可以要求我做你想要而我不喜欢的东西，然而你并不理解我想要什么。”相似的处境，能让我对这个儿子的理解多一些，对于他的冷漠反而不会过分苛责。我觉得他只是把自己包在了一个壳里面，把曾经所受到过的冷暴力用不一样的方式还回去，即使那些伤害并不是父亲带来的。<br>&nbsp;&nbsp;古语说解铃还须系铃人，可有些时候，那个系铃铛的人早已经不在了。我想，我们还是应该对身边的人多一些善待，因为谁都不知道对你微笑的那副脸庞曾经经历过什么。对那个儿子，相信他一定也会知道，成长过程中的那些伤带来的影响不会仅仅只有影响。在给予我们不开心的那些人面前，回击他们的方式要么是以数倍的力量反击回去，要么宽容或者原谅，哪一种都需要漫长的时间和心智的积累。希望你好。</font>

<h3 id="看书才能写出文章来"><a href="#看书才能写出文章来" class="headerlink" title="看书才能写出文章来"></a><font color="#B96969" size="4.0" face="黑体">看书才能写出文章来</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;我站在桥上看风景，看风景的人在桥上看你。我们羡慕大理客栈老板的悠闲，羡慕辞了稳定工作去开自己马场的美女老板，可是不知道老板也为淡季客源发愁，美女为每天马粪烦恼。他们的生活你不一定真的想要，你的生活也许还好。多读读书，别在看着人家股票牛市赚的盆满钵满时候，还不理解什么叫做做T；别在人家研究虚拟货币的时候，才开始接触支付宝。保持对这个世界的好奇，不能行万里路，也从别人走过的经验里面领悟一些知识。你见了哪个富豪取了一位只有白腿没有脑袋的太太？</font>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/19/生活在别处/" data-id="ciznrq4530018eoux0pbp9zyt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-艰难的第二记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/18/艰难的第二记/" class="article-date">
  <time datetime="2016-12-18T02:28:12.000Z" itemprop="datePublished">2016-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/18/艰难的第二记/">艰难的第二记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">一个好习惯的养成,大概需要21天;如果没有一个明确的目标,没有足够的动力,21天里的每一天都是个劫难(=@__@=)。这么想来，之前自己坚持每天写东西的小习惯，相对于我这个越来越懒的人来说略有些伟大。好在完成一件是之后能够带来持续的满足感和自信心，而这也许会是自己能够坚持下去的最好原因。</font> 

</blockquote>
<font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;说笑之外，现在的每日一记和之前的日记有一些区别，从前主要记录每天的心情感受，所想与所得，简单来说是一个女儿家的小情切。而现在希望每天写下的东西不只是面对自己，而是面对有天可能看到文字的所有读者。这样写的东西会更负责任，思想的更周全。也能每天倒逼自己做出更多输入。为了让这一篇写起来不会像倒饺子的茶壶，白天时候故意做了一些功课，争取能够在1小时完成2500字左右，这作为今天的目标。</font>

<font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;难得清闲的周六，看了俩档中央卫视的节目《挑战不可能》、《和全世界做生意》。 今天的文章，想聊聊自己对于’专业性’的看法。</font>

<h3 id="挑战不可能"><a href="#挑战不可能" class="headerlink" title="挑战不可能"></a><font color="#B96969" size="4.0" face="黑体">挑战不可能</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;‘不可能’节目里面有位来自非洲的小伙，他的花式足球现在已经成为了巴黎50个必去景点之一。他的挑战项目是天梯颠球，作为观察者审视别人的挑战时，经常会低估项目的难度。天梯共70阶，最高处与地面所成夹角为65°。仔细想来，脚上没有足球动作，一节一节毫无间断的爬上去对于一个体力正常的年轻人也不容易。而伊娃需要背对台阶脚颠足球倒着跳到最高点，才能算挑战成功。第一次，35阶处足球飞走；没有一秒间歇，开始了第二次，50阶处又败；节目的嘉宾说那个位置恰好是和更上一级衔接的地方，所以阶梯会变窄（天梯是伸缩式的），他俩次失败都没让自己觉得意外，因为这个挑战无论是体力还是耐力都是个极大极大的考验。短暂休息开始的第三次，才是真的令人觉得无限遗憾又深感惋惜的一次，这也是自己头次对足球项目报这么大的兴趣，也许是由于男女天生运动神经构造不一样，我始终不能理解十多个身强体壮的男人对一个球滚来滚去的兴趣和男人不能理解我们对于逛来逛去却什么都不买是一个道理。伊娃在第69级，大家已经准备好了为他的成功欢呼鼓掌的时候，球又飞走了，李昌钰博士说他的头已经到了70那里，所以算是另一种成功。失败时候没有流出的眼泪，偏偏在听到安慰与鼓励时流出来了。由于家中经济原因，在本应该读专业学校的时候，伊娃选择了撑起家中的担子放弃了求学之路，而今登上大屏幕，屏幕那一面仍然有许多没有好条件的兄弟姐妹邻里乡亲，希望他能成功，可是最后一刻，偏偏没有得到渴望的结果。<br><br>&nbsp;&nbsp;我不知道他每一级向前的背后有多少汗水，受过多少奚落，忍受了多少别人不能忍的痛苦。拼搏的路程常有一些相似的地方，他的泪水能唤起自己心里的共鸣，是因为在那个憨厚的小伙身上看到了一些自己和身边许多人的影子。我们生活的年代，物质并不匮乏，已经很少有人会因为吃不饱饭，穿不暖衣而饿死。按照马斯洛的需求理论，现在人追求的满足很大一部分都属于精神层面，可我们却多了越来越多的焦虑和抱怨，虽然每个时代都有相应的烦恼，若是能够在这些烦恼的间隙学学伊娃身上的坚韧，生活也许会变得阳光很多。哪位名人说的：有裂缝的地方，才能照进来阳光。论花式足球，伊娃可能没有受过专业训练，但这不阻碍我对他‘专业’表演的敬佩。</font>

<h3 id="在全世界做生意"><a href="#在全世界做生意" class="headerlink" title="在全世界做生意"></a><font color="#B96969" size="4.0" face="黑体">在全世界做生意</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;另一档节目中的一段讲的事德清母女在甘肃仁多玛开了围巾工坊“诺乐”。藏语中，诺乐是牦牛的意思，同时寓意吉祥。无论在电视节目中，还是生活中遇到的（寥寥无几）外国友人几乎总是能给人一副乐观阳光，积极向上的印象，而且越是优秀的高材生越能够以心怀天下为己任，最后呈现出来的结果却都是我这样一切’朝钱看’的人想要达到的。有时候，会反省自己是不是因为太急功近利了，才把生活过得好像一团乱糟糟，真的有那么不堪么？德清说她最开始想要留在那个海拔3000米的小村庄，并不是为了赚钱，只是希望帮助当地的藏民搭起一座和世界沟通的桥梁，帮那里打通和世界的贸易，让藏民们过上富足一些的生活。节目中的德清，脸上有俩团高原红，我猜想，在陆地生活的时候她一定是个很美丽的女子。当她的愿望稍微实现一些，订单量变大，工坊需要扩张的时候，需要习惯了自由自在的牧民们加班加点完成客户的需求。有些人开始说她去仁多玛只是为了赚钱，为了满足自己的愿望。最难得考验好像常会在生活美满的时候出现，特别想她能够挺过难关，她的母亲也说“做事情并不是为了要别人赞同自己，而是自己认为正确，就去做”。虽然年龄相仿，无论能力还是胸襟她都该是高了自己好几个等级，总有许多人是这样，他们比你优秀比你天分好，可是还比你努力。在围巾的领域中，能够以自己的视角和产品立足，除开故事本身，和她对于市场的专业判断有很大关系。有一天，我们也会成为这样的人。</font>

<h3 id="偶尔得喝鸡汤"><a href="#偶尔得喝鸡汤" class="headerlink" title="偶尔得喝鸡汤"></a><font color="#B96969" size="4.0" face="黑体">偶尔得喝鸡汤</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;说一万句很有道理的话，都没有践行一件很简单的事来得更有说服力，要做个’专业’的人。</font>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/18/艰难的第二记/" data-id="ciznrq45i001jeoux1gsleoas" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-发烧以后" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/16/发烧以后/" class="article-date">
  <time datetime="2016-12-16T09:27:06.000Z" itemprop="datePublished">2016-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/16/发烧以后/">发烧以后 ^_^</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font color="#696969" size="3.5" face="黑体"><br>&nbsp;&nbsp;昨天夜里开始浑身发冷,在被窝里面缩成一团,只觉难受,并没想到会发烧.晨起,收拾完毕,一切照旧,去公司上班,这一天的噩梦开始了,在地铁上的时候只是头晕,下了地铁走路开始吃力。在公司趴一小时，冷到不能自已。打车回家。测体温—38.7°，记忆里面已经很久没有发烧了，何况是这么高的温度，心里竟有一丝丝窃喜，这要是发到朋友圈，应该能得到好几个赞。在床上瘫了一整天，晚上9点体温达到了38.9。睡了一晚，烧退了，胃开始疼。<br><br>&nbsp;&nbsp;自己也不清楚，身体上体现出来的种种不适，到底是因为真的病了，还是这段时间来一直紧绷的情绪出现了物理反应。近一个月自己的精神状态始终在一个不可控的状态。严重的时候，好像胸中有团怒火，嘶吼着要从头顶喷涌而出。遇到了超出解决范围的问题，也不知道该找个什么样的发泄口，然后抑郁堆积在心里，由土堆变成了丘陵。除了不断感受到自己的无助，我为自己做的只有不停地慌张和焦虑，像生活明天要停止了一样。<br><br>&nbsp;&nbsp;11月份时候，听了一场李笑来老师的网络直播课，一小时的直播有60多万人参与。因为自己书读的太少，吸收的知识有限。昨天，又听笑来老师推荐的“普通人快速崛起的10大狠招”，俩场讲座里面都提到的每日写作这个观点，让心里捡起写日记的小火苗燃了起来。谨此，将猫老师讲座里面的一些感受记下来，为每日一次开个头。</font>

<h3 id="一、个人品牌"><a href="#一、个人品牌" class="headerlink" title="一、个人品牌"></a><font color="#B96969" size="4.0" face="黑体">一、个人品牌</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;厂家都讲究品牌效应，酒香不怕巷子深的道理没有错，然而不能作为这个互联网时代的普适定律。如果能够找到自己喜欢并愿意坚持的事情作为突破，打造出个人品牌，一定会有很多意想不到的收获。iOS开发是要求有一定的经验和教育背景的工作，但是Apple一家独大的局面加上现在市场上供小于求的供应关系,自己不出色的硬件实力，会经常让人陷入一种绝望而不能自拔。我开始发现周围的人都在使用和安装微信时，智能手机还没有完全普及，许多人使用它“摇一摇”的功能来方便快速的和陌生人交往，既新鲜又好奇。而发展至今，微信已经变成了熟人社交圈里面岿然不动的一座大山，有很多科技类和新媒体网站都会说，能在社交领域有建树，需要选一条和微信不一样的路。偶尔午后吃完饭，会和三俩个跟自己一样的程序员屌丝讨论一下民生大事，科技发展等等略吹牛逼的话题。我们许多人都认为：腾讯成就了微信，微信也成就了腾讯。 天下熙熙皆为利来，天下攘攘皆为利往。微信的成功有他的独特和不可替代性，张小龙的成功之路也不能复制。这个世界唯一不变的是变化。</font>

<h3 id="二、读书的质量"><a href="#二、读书的质量" class="headerlink" title="二、读书的质量"></a><font color="#B96969" size="4.0" face="黑体">二、读书的质量</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;《如何阅读一本书》这本书里面，贯穿始终的一个观点是：书读的数量不在多，而在于精。猫老师却认为读书首先要量大，这样才能够在遇到一件事或者一个观点时从大量的书里面找到可以为自己佐证的论点。俩种观点，各有各的道理。能够保持大量又高质的阅读能够结合二者精华，但对于像我这样的读者确实有些难度。古人云“鱼和熊掌，不可兼得”。所以我想在开始没有掌握读书的方法和技巧的时候应该向《阅读》里说的，将阅读分为几个层次和几个大步。能够熟练运动这些方法时，从各类书籍中汲取自己需要的，大量的翻阅书籍是比较适合自己的。开卷有益，毋庸置疑的是，每个走到了自己理想状态的人，一定读过许多书。<br>&nbsp;&nbsp;这让我想起那个开除我的女领导。作为清华建筑系的女高材生，她虽然有点暴躁（这点我和她hin相似），可在许多方面都有自己独到的见解和思维方式。虽然把我开除这件事，令自己心碎，以至于在现有公司呆了俩年仍然时时刻刻担心自己做的不好，但还是会偷偷的通过各种方式关注她。通过各类自我介绍，以及相处的短暂的俩个月，我知道她从小已经读过许多许多书，上知天文地理，下知宇宙哲学；会溜冰，会画画，养过狼，养过狗，能文能武，能缩能伸。简直是自己梦里的样子，可这个梦里的样子跳到现实来，居然把自己开除了，说明现实中的我还有许多需要修炼的地方。她能快速阅读一本书，并在书中找到自己想要看的东西，单这一点是我要很久才能学来的。每一笔经历都会成为财富，我在心里感谢过她很多次，也希望自己早一天变成理想状态。</font>

<h3 id="三、采访"><a href="#三、采访" class="headerlink" title="三、采访"></a><font color="#B96969" size="4.0" face="黑体">三、采访</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;猫老师说，快速学习的方式之一是采访各个行业的顶尖人才。以自己当前这个身份采访这个词，可能有些夸张了，别说采访了，见都见不到。可这的确为一个好办法，我采访不到，但各个知名的主持人能见到啊，看他们的采访又能省去自己找人的时间，又能够学习，一箭双雕。为自己的机智点个赞。名人自传也是个学习的好途径，这又回到了上一点，好好掌握读书的方法。</font> 

<h3 id="四、知识分享"><a href="#四、知识分享" class="headerlink" title="四、知识分享"></a><font color="#B96969" size="4.0" face="黑体">四、知识分享</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;彻底掌握一门知识的最好办法是讲给别人听。这个观点听很多人说过了，可平时见不到那么多人，好在有可替代的办法：把所学写成文章整理出来，在写文章的过程中会将思路理顺打通。写作这件事，难在了用心把东西写好并且不会让别人读起来觉得恶心。除此之外，需要有足够的精力配合。我关注了许多微信公众号，有很多公众号作者特别勤劳，每天都有产出，且篇篇都有觉得很有道理，日常生活中发生的小事经过他们的笔变得有趣生动，所谓妙笔生莲花，应该就是这意思。可知识分享，首先得有知识，提笔脑空，分享什么呢？于是又扯出了俩个点：1.知识丰富 2.提笔成章。贫瘠的土壤尚且种不出肥沃的土地；怎么能指望空空的脑袋，给别人说些令人信服的观点。<br><br>&nbsp;&nbsp;上面的几个点是听猫老师讲座中有感想的一部分，将讲座的听后总结作为日日记的第一篇，因为猫老师本人是每日写作的受益者；又因为他的讲座是付费直播，我想对得起自己付出的每一分钱；还因为自己之前喜欢将每天发生的事情写下来，希望能将这个事情重新捡起来，即使不能够从中受益，每天写点东西也能让每天孤单的生活丰富多彩。老师们要求每天3000字，今天初试，2000多字写了3个多小时，惊讶于自己笔下没墨，也有点担心工作后没有这么多的时间和精力。但我必须把这个事情坚持下来，至少得回到高中时候的写文字水平吧？！3个小时写这么点，都对不起这大好的时间，(；′⌒`)</font>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/16/发烧以后/" data-id="ciznrq42h000eeouxvsi06m0l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-播放本地音频" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/iOS-播放本地音频/" class="article-date">
  <time datetime="2016-10-24T10:05:02.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/iOS-播放本地音频/">iOS 播放本地音频</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#0099ff" size="3" face="黑体">产品同学想要实现一个功能:用户完成某个任务时,进行语音提示. 于是这个简单的要求,折磨我3天(；′⌒`), 实践证明,开发之前的充分调研能够少走弯路; 开发经验也的确能够缩短开发时间</font>

</blockquote>
<h2 id="那些自己尝试-zou-过-guo-的-de-方-wan-法-lu-💨"><a href="#那些自己尝试-zou-过-guo-的-de-方-wan-法-lu-💨" class="headerlink" title="那些自己尝试(zou)过(guo)的(de)方(wan)法(lu)💨"></a>那些自己尝试(zou)过(guo)的(de)方(wan)法(lu)💨</h2><ul>
<li>定时声音推送(UILocalNotification), 类似闹钟的功能,到了指定时间后,响起一段音乐. 然而这样做的问题在于,并不知道用户什么时候做任务; 且任务切出界面后,任务需要结束. 本地通知不能满足要求ˇˍˇ ,放弃</li>
<li>AVAudioPlayer播放本地音频, 这个好,棒极了,开发完之后,发现产品需要音乐能够后台配置(论读懂需求的重要性),且音乐时长也许会超过30s. 再弃</li>
<li>最后选择了AVPlayer</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.AVAudioPlayer和AVPlayer声明对象都需要设置成全局变量<br>2.AVAudioPlayer和AVPlayer都需要引入AVFoundation框架<br>3.iOS9引入了新特性App Transport Security (ATS),需要在plist中添加权限. 添加方式:左键Info.plist选择open with source code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>
<h2 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h2><p>1.加载音频文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//播放本地音频</span><br><span class="line">  NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;独角戏&quot;  ofType:@&quot;mp3&quot;];</span><br><span class="line">  NSURL *sourceMovieUrl =  [NSURL fileURLWithPath:filePath];</span><br><span class="line">  //播放网络音频</span><br><span class="line">  //NSURL *sourceMovieUrl = [NSURL URLWithString:urlString]</span><br></pre></td></tr></table></figure>
<p>上面的代码中本地音频和在线音频的主要区别在于路径的不同:本地路径使用<code>[NSURL fileURLWithPath:本地音频路径]</code>,在线音频使用<code>[NSURL URLWithString:在线音乐地址]</code></p>
<p>2.创建AVPlayer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVAsset *movieAsset = [AVURLAsset URLAssetWithURL:sourceMovieUrl options:nil];</span><br><span class="line">self.timerPlayerItem = [AVPlayerItem playerItemWithAsset:movieAsset];</span><br><span class="line"></span><br><span class="line">//这是用来支持后台播放的</span><br><span class="line">AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">NSError *setCategoryError = nil;</span><br><span class="line">[audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;setCategoryError];</span><br><span class="line"></span><br><span class="line">[audioSession setActive:YES error:nil];</span><br><span class="line">if (setCategoryError) &#123;</span><br><span class="line">    NSLog(@&quot;这里有问题 %@&quot;,setCategoryError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.timerPlayer = [[AVPlayer alloc]initWithPlayerItem:self.timerPlayerItem];</span><br></pre></td></tr></table></figure>
<p>有了音频文件的路径,剩下的就是将音乐播放出来了.上面的代码有俩个作用:1.创建AVAudioSession使得播放器支持后台播放 2.创建音频播放器. 其中代码中用到的<code>AVAsset</code>是个抽象类,不能够单独使用.</p>
<p>3.播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.timerPlayer play];</span><br></pre></td></tr></table></figure>
<p>如果仅仅是播放音乐,上面的代码就足够了,但往往播放音乐后还需要许多操作,比如音乐完成后界面需要提示啊,音乐播放进度等等. 于是就有了下面的监听</p>
<p>4.添加和移除监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加监听</span><br><span class="line">- (void)addObserverForPlayerItem</span><br><span class="line">&#123;</span><br><span class="line">    [self.timerPlayer.currentItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    [self.timerPlayer.currentItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    //添加音乐播放完成的通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidFinishPlaying) name:AVPlayerItemDidPlayToEndTimeNotification object:self.timerPlayer.currentItem];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除监听</span><br><span class="line">- (void)removeObserverForPlayerItem</span><br><span class="line">&#123;</span><br><span class="line">    [self.timerPlayer.currentItem removeObserver:self forKeyPath:@&quot;status&quot;];</span><br><span class="line">    [self.timerPlayer.currentItem removeObserver:self forKeyPath:@&quot;loadedTimeRanges&quot;];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:AVPlayerItemDidPlayToEndTimeNotification object:self.timerPlayer.currentItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码利用KVO属性监听了<code>status</code>和<code>loadedTimeRanges</code>属性,并添加了<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知;<code>status</code>是对player的状态的枚举值,当<code>status = readytoplay</code>时候才能播放资源或进行其他的界面处理,<code>loadedTimeRanges</code>的属性监听可以获得当前资源的缓冲进度.下面是对属性监听后的操作示例和收到<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知后执行的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;status&quot;]) &#123;</span><br><span class="line">        int status = ((NSNumber *)change[@&quot;new&quot;]).intValue;</span><br><span class="line">        if (status == AVPlayerStatusReadyToPlay) &#123;</span><br><span class="line">            //进行相应的界面处理</span><br><span class="line">            NSLog(@&quot;hehehheeh&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;else if ([keyPath isEqualToString:@&quot;loadedTimeRanges&quot;])&#123;</span><br><span class="line">        NSArray *array = self.timerPlayer.currentItem.loadedTimeRanges;</span><br><span class="line">        CMTimeRange timeRanges = [array.firstObject CMTimeRangeValue];</span><br><span class="line">        float startSeconds =  CMTimeGetSeconds(timeRanges.start);</span><br><span class="line">        float durationSeconds = CMTimeGetSeconds(timeRanges.duration);</span><br><span class="line">        //获取缓冲时间</span><br><span class="line">        float bufferTime = startSeconds + durationSeconds;</span><br><span class="line">        NSLog(@&quot;%f&quot;,bufferTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)itemDidFinishPlaying</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;终于完事了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了上面这些代码,基本能够满足产品对于播放音乐的需求了.但是考虑到配置的提示音并不长,所以领导希望音频缓存到本地后再进行播放,所以接下来需要下载音乐文件</p>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>1.设置本地文件的存储路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 下载后的音频存放路径</span><br><span class="line"></span><br><span class="line"> @param fileName         文件名称</span><br><span class="line"> @param isFileExistBlock 回调</span><br><span class="line"> */</span><br><span class="line">- (void)audioFilePath:(NSString *)fileName</span><br><span class="line">          isFileExist:(void(^)(BOOL isExist, NSString*savePath))isFileExistBlock</span><br><span class="line">&#123;</span><br><span class="line">    NSString *cachePath=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    </span><br><span class="line">    NSString *savePath=[cachePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;audio_%@&quot;,fileName]];</span><br><span class="line">    NSLog(@&quot;%@&quot;,savePath);</span><br><span class="line">    </span><br><span class="line">    //首先判断当前路径是否存在</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    BOOL isPathExist = [fileManager fileExistsAtPath:savePath];</span><br><span class="line">    if (isPathExist)</span><br><span class="line">    &#123;</span><br><span class="line">        //存在相同的文件</span><br><span class="line">        if (isFileExistBlock) &#123; isFileExistBlock(YES, savePath); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        if (isFileExistBlock) &#123; isFileExistBlock(NO, savePath); &#125;</span><br><span class="line">        //判断当前路径下文件个数,个数大于5时,删除文件</span><br><span class="line">        NSArray *array = [fileManager contentsOfDirectoryAtPath:savePath error:nil];</span><br><span class="line">        if (array.count &gt; 4)</span><br><span class="line">        &#123;</span><br><span class="line">            [fileManager removeItemAtPath:savePath error:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码做了一个对缓存文件的简单判断:当缓存文件已经存在的时候,返回标识符YES;缓存文件数量大于4时删除沙盒中的文件</p>
<p>2.下载资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据链接地址下载音频</span><br><span class="line"></span><br><span class="line"> @param urlString 下载</span><br><span class="line"> @param block     block</span><br><span class="line"> */</span><br><span class="line">- (void)downLoadAudioWithUrlString:(NSString *)urlString</span><br><span class="line">                     downloadBlock:(DownloadAudioFinishBlock)block</span><br><span class="line">&#123;</span><br><span class="line">   // NSURL *soundURL = [NSURL URLWithString:@&quot;http://yinyueshiting.baidu.com/data2/music/122873158/4904681476817261128.mp3?xcode=1276ea4c54f0c8f829676627b54cb918&quot;];</span><br><span class="line">    NSURL *soundURL = [NSURL URLWithString:urlString];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;soundURL:%@&quot;,soundURL);</span><br><span class="line">    </span><br><span class="line">    //将路径拆分成array,然后保存文件名称</span><br><span class="line">    NSArray *seperateArray = [urlString componentsSeparatedByString:@&quot;/&quot;];</span><br><span class="line">    NSString *fileName = seperateArray.lastObject;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self audioFilePath:fileName isFileExist:^(BOOL isExist, NSString *savePath)</span><br><span class="line">     &#123;</span><br><span class="line">         //存在文件</span><br><span class="line">         if (isExist)&#123;</span><br><span class="line">             if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //不存在文件</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             //创建网络请求</span><br><span class="line">             NSMutableURLRequest *theRequest = [NSMutableURLRequest requestWithURL:soundURL];</span><br><span class="line">             NSURLSession *session  = [NSURLSession sharedSession];</span><br><span class="line">             </span><br><span class="line">             //根据链接地址下载音频到指定地址</span><br><span class="line">             NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:theRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">                 if (!error) &#123;</span><br><span class="line">                     </span><br><span class="line">                     //注意location是下载后的临时保存路径,需要将它移动到需要保存的位置</span><br><span class="line">                     </span><br><span class="line">                      NSError *saveError;</span><br><span class="line">                      //存储文件</span><br><span class="line">                      NSURL *saveUrl=[NSURL fileURLWithPath:savePath];</span><br><span class="line">                      [[NSFileManager defaultManager] copyItemAtURL:location toURL:saveUrl error:</span><br><span class="line">                       &amp;saveError];</span><br><span class="line">                      if (!saveError) &#123;</span><br><span class="line">                          NSLog(@&quot;save sucess.&quot;);</span><br><span class="line">                          if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">                      &#125;else&#123;</span><br><span class="line">                          NSLog(@&quot;error is :%@&quot;,saveError.localizedDescription);</span><br><span class="line">                          if (block) &#123; block(nil, saveError);&#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                 </span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     NSLog(@&quot;error is :%@&quot;,error.localizedDescription);</span><br><span class="line">                     </span><br><span class="line">                     if ([error.localizedDescription containsString:@&quot; already exists&quot;]) &#123;</span><br><span class="line">                         if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">                     &#125;else&#123;</span><br><span class="line">                         if (block) &#123; block(nil, error);&#125;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 </span><br><span class="line">             &#125;];</span><br><span class="line">             [downloadTask resume];</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的url是从百度中找到的音乐下载地址,这里下载音乐和文件是一样的,如果网速太慢,建议找个短点的音乐或者文件之类.此处存放音乐的名称为url截取的一部分. 这样下载文件就完成啦.</p>
<p><a href="https://github.com/XQ0820/PlayAudio" target="_blank" rel="external">上面文章的代码放在这里了:</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前听李笑来老师的讲座,他提到”输出能够有效地推动输入”. 自己写这篇文章略略能感受到这一点,平时读别人的技术博客总是3~5分钟就看过去了,现在想想应该好好感谢所有给自己提供过帮助的博客.有了谷歌,就好像拥有整个宇宙,也希望能通过博客的形式给自己增加一些新鲜的感受,和多一些进步.</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>Hale’s Blog: <a href="http://wuqiuhao.github.io/2016/04/05/iOS%E8%A7%86%E9%A2%91%E3%80%81%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="external">http://wuqiuhao.github.io/2016/04/05/iOS%E8%A7%86%E9%A2%91%E3%80%81%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/</a><br>iOS 音频播放 —— 离线歌曲:<a href="http://www.jianshu.com/p/2fdc6a9142c4" target="_blank" rel="external">http://www.jianshu.com/p/2fdc6a9142c4</a><br>码农人生音频播放系列(大神的文章牛牛哒!):<a href="http://msching.github.io/blog/2014/07/08/audio-in-ios-2/" target="_blank" rel="external">http://msching.github.io/blog/2014/07/08/audio-in-ios-2/</a><br>AVAudioPlayer,AVPlayer以及系统音频:<a href="http://www.jianshu.com/p/e5dbd92871a4" target="_blank" rel="external">http://www.jianshu.com/p/e5dbd92871a4</a><br>iOS音频篇：使用AVPlayer播放网络音乐:<a href="http://www.jianshu.com/p/32b932f44c9b" target="_blank" rel="external">http://www.jianshu.com/p/32b932f44c9b</a><br>iOS Programming 101: Record and Play Audio using AVFoundation Framework:<a href="https://www.appcoda.com/ios-avfoundation-framework-tutorial/" target="_blank" rel="external">https://www.appcoda.com/ios-avfoundation-framework-tutorial/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/iOS-播放本地音频/" data-id="ciznrq4160003eouxg31eemrn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-iOS10用户通知框架-User-Notifications-简介-翻译" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/" class="article-date">
  <time datetime="2016-10-17T02:27:24.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/">iOS10用户通知框架(User Notifications)简介(翻译)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>原文链接</strong>: <a href="http://www.appcoda.com/ios10-user-notifications-guide/" target="_blank" rel="external">http://www.appcoda.com/ios10-user-notifications-guide/</a></p>
<p>大家好,欢迎来到iOS10教程的通知指南. 今天,我们将聊一下在iOS10系统中如何实现通知. iOS10的通知API新增和修改了许多特性,包括基于触发器(triggers)的牛掰的请求系统,详细内如会在下文中详细讨论.<br>iOS10通知中最大的改变是<code>UserNotificationsUI</code>的框架,它可以在通知中自定义视图控制器.这就允许创建许多之前系统中完全不可能的很有用的各种通知</p>
<h2 id="简单的用户通知"><a href="#简单的用户通知" class="headerlink" title="简单的用户通知"></a>简单的用户通知</h2><p>我们想要展示的通知并不全是精致且可交互的.因此,接下来开始演示怎么建立一个基本的文本通知.下载<a href="https://github.com/appcoda/NotificationsUI-Demo/raw/master/NotificationsUI.zip" target="_blank" rel="external">初始工程</a>并打开 <code>NotificationsUI.xcodeproj</code>. 看一下整个工程,你会发现什么都没有:我们用 <code>Main.storyboard</code> 结合 <code>ViewController.swift</code> 和 <code>AppDelegate.swift</code> 进行用户交互<br><img src="/img/14764273540293.png" alt=""></p>
<p>打开 <code>Main.storyboard</code> 看一下 <code>ViewController</code> 文件. 今天我们做的这个apple用来提醒用户上网月度AppCoda的文章.它让用户选择需要通知的日期和时间.首先对这个app做一简单的修改:启用通知. 目前选择时间和日期一点用都没有.我们将要更新这个app,使得它在设置时间和日期后在指定时间创建通知.</p>
<p>继续打开 <code>ViewController.swift</code> 让我们开始吧.</p>
<p>当你打开 <code>ViewController.swift</code> 时, 你会发现文件很空. 只有一个在时间选择器选择了新的时间后,会被调用的功能函数<code>datePickerDidSelectNewDate</code>.像前面提到的,现在这个app除了创建通之外什么都没做. 让我们来实现这个功能</p>
<p>在iOS10中创建通知的过程有一点变化.开发人员现在必须创建<em>requests</em>,向iOS请求展示通知.这些请求包括俩部分: <em>triggers</em> 和 <em>content</em> (触发器和内容).一个触发器是一系列发送通知所必须满足的条件.为了在iOS10中显示一个通知,首先从触发器开始.我们使用的基于时间的触发器的类是<code>UNCalendarNotificationTrigger</code>. Apple提供了也提供了其他的类,例如 <code>UNLocationNotificationTrigger</code> (当用户到达指定地点时触发通知)</p>
<p>像上面声明的: 在iOS中展示通知的第一步是创建一个触发器.现在,让我们继续并且创建一个触发器.</p>
<p>打开 <code>AppDelegate.swift</code>, 确保已经导入了 <code>UserNotification</code>框架, 所有通知相关的API都在这个框架里面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import UserNotifications</span><br></pre></td></tr></table></figure>
<p>接下来,添加函数<code>scheduleNotification(at date: Date)</code>.名如其义,这个函数负责在提供的日期内定制一个通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func scheduleNotification(at date: Date) &#123;</span><br><span class="line">    let calendar = Calendar(identifier: .gregorian)</span><br><span class="line">    let components = calendar.dateComponents(in: .current, from: date)</span><br><span class="line">    let newComponents = DateComponents(calendar: calendar, timeZone: .current, month: components.month, day: components.day, hour: components.hour, minute: components.minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中, 使用 <code>Gregorian</code> 日历将提供的日期分成几个组件.日期与组件不在这个教程的范围内,但需要知道一个日期由组件组成.单独展示日期的组件,例如小时,分钟,秒等.刚才的代码将时间拆分成组件并保存在 <code>components</code> 常量中.这样做是因为执行 <code>UNCalendarNotificationTrigger</code> 需要日期组件而不是日期. 然而, <code>UNCalendarNotificationTrigger</code>比较诡异的一点是直接从日期中取出完整的组件并不能使用, 而需要从已存在的实例中读取信息创建自己的 <code>DateComponents</code> 实例. 第三行代码就是做这个的:它只是从 <code>date</code> 中获取了相关信息创建了新的 <code>DateComponents</code> 实例.</p>
<p>现在有了 <code>date</code> 的组件, 继续啊创建日历通知触发器. 像在iOS中的其他东西一样, <em>Apple</em>使这个创建过程相当简单. 只需要将下面的代码加入函数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let trigger = UNCalendarNotificationTrigger(dateMatching: newComponents, repeats: false)</span><br></pre></td></tr></table></figure></p>
<p>跟预想的一样,这行代码用时间组件创建了新的 <code>UNCalendarNotificationTrigger</code>. 因为只需要通知出现一次,将<code>repeats</code>设置为 <code>false</code>.</p>
<p>现在已经创建完触发器,接下来的就是创建需要在通知中展示的 <em>content</em>. 这可以通过 <code>UNMutableNotificationContent</code> 类完成. 将下面几行代码放在 <code>trigger</code> 变量的下面创建通知内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let content = UNMutableNotificationContent()</span><br><span class="line">content.title = &quot;Tutorial Reminder&quot;</span><br><span class="line">content.body = &quot;Just a reminder to read your tutorial over at appcoda.com!&quot;</span><br><span class="line">content.sound = UNNotificationSound.default()</span><br></pre></td></tr></table></figure>
<p>这些代码就能理解其含义:我们创建了一个新的 <code>UNMutableNotificationContent</code> 实例, 然后设置它的标题, 内容, 声音.</p>
<p>看起来好像我们已经准备好展示第一个通知了. 然而,还剩俩步需要完成:1.创建通知<em>request</em>, 2.将它提供给系统,告诉iOS展示通知.</p>
<p>为了创建通知请求,用相关的内容和触发器初始化一个 <code>UNNotificationRequest</code> 对象.还需要一个唯一标识码用来识别这个通知请求. 在 <code>scheduleNotification</code>函数中插入下面这行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let request = UNNotificationRequest(identifier: &quot;textNotification&quot;, content: content, trigger: trigger)</span><br></pre></td></tr></table></figure></p>
<p>很简单,对么?创建请求需要3个参数:</p>
<ul>
<li><code>identifier</code>: 这是我们请求的唯一标识.你很快就会看到,这个标识能用来取消通知请求.</li>
<li><code>content</code>: 这是之前创建的通知内容</li>
<li><code>trigger</code>: 这个触发器用来触发通知.当满足触发条件后,iOS将会展示这个通知</li>
</ul>
<p>好了,现在要做的最后一件事是将请求添加进管理整个app所有通知的通知中心.通知中心会根据合适的时间触发通知.</p>
<p>将通知请求加入通知中心之前,最好先将已经存在的通知请求移除, 这样能够避免重复通知. 将下面的代码段加入函数中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter.current().removeAllPendingNotificationRequests()</span><br><span class="line">UNUserNotificationCenter.current().add(request) &#123;(error) in</span><br><span class="line">    if let error = error &#123;</span><br><span class="line">        print(&quot;Uh oh! We had an error: \(error)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码得到通知中心的单例并调用 <code>removeAllPendingNotificationRequests</code> 方法移除所有挂起的通知请求.然后将请求加入通知中心.这个方法也在函数完成后也会调用.在我们实现中,这个控制器用来打印错误. 在继续操作之前, 确保 <code>scheduleNotification</code> 函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func scheduleNotification(at date: Date) &#123;</span><br><span class="line">    let calendar = Calendar(identifier: .gregorian)</span><br><span class="line">    let components = calendar.dateComponents(in: .current, from: date)</span><br><span class="line">    let newComponents = DateComponents(calendar: calendar, timeZone: .current, month: components.month, day: components.day, hour: components.hour, minute: components.minute)</span><br><span class="line">    </span><br><span class="line">    let trigger = UNCalendarNotificationTrigger(dateMatching: newComponents, repeats: false)</span><br><span class="line">    </span><br><span class="line">    let content = UNMutableNotificationContent()</span><br><span class="line">    content.title = &quot;Tutorial Reminder&quot;</span><br><span class="line">    content.body = &quot;Just a reminder to read your tutorial over at appcoda.com!&quot;</span><br><span class="line">    content.sound = UNNotificationSound.default()</span><br><span class="line">    </span><br><span class="line">    let request = UNNotificationRequest(identifier: &quot;textNotification&quot;, content: content, trigger: trigger)</span><br><span class="line">    </span><br><span class="line">    UNUserNotificationCenter.current().removeAllPendingNotificationRequests()</span><br><span class="line">    UNUserNotificationCenter.current().add(request) &#123;(error) in</span><br><span class="line">        if let error = error &#123;</span><br><span class="line">            print(&quot;Uh oh! We had an error: \(error)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果代码和上面的一样,准备出发吧! 现在我们需要做的是在 <code>ViewController.swift</code>中配置当用户选择时间后调用<code>scheduleNotification(date:)</code> .在 <code>ViewController.swift</code>中,将下面的代码加入<code>datePickerDidSelectNewDate</code> 方法中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let selectedDate = sender.date</span><br><span class="line">let delegate = UIApplication.shared.delegate as? AppDelegate</span><br><span class="line">delegate?.scheduleNotification(at: selectedDate)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码获取到了当前应用正在使用的的<code>AppDelegate</code>实例并用之前写的的函数定制通知.快来试试吧!运行app并选择未来的时间.等到设备时间到选择时间后看看发生了什么!</p>
<p>呃,通知没出现,但是为什么呢?</p>
<p>这有一些通知没出现的原因.</p>
<p>首先,苹果致力于在iOS上保持一个完美的用户体验,体验的一部分是给用户提供从app内接受通知的控制权限.用户还没有授权展示通知,这就是为什么通知没有展现的原因.</p>
<p>让我们修复这个问题.将下面的代码加入 <code>AppDelegate.swift</code>的方法中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123;</span><br><span class="line">    </span><br><span class="line">    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) &#123;(accepted, error) in</span><br><span class="line">        if !accepted &#123;</span><br><span class="line">            print(&quot;Notification access denied.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们调用通知中心的<code>requestAuthorization</code>方法来获得用户使用通知的许可.我们也请求展示<br>告警和声音的能力.</p>
<p>现在重新运行app.当app加载后,你会看见授权请求.确保你同意,然后app能够向设备发送通知.</p>
<p>另一件你需要记住的是,这个通知不会再app内展示.因此,一旦你设置了日期,确保你返回主屏幕并锁屏.<br>如果所有步骤都准确无误,通知就会出现啦!<br><img src="/img/14764376688190.jpg" alt=""></p>
<p>看见没? 向iOS用户发送通知没那么难, 只需要先执行一些预提示的步骤,例如请求通知权限.现在已经发送了简单的文本,让我们再加一张图片!</p>
<h2 id="在通知中附加图片"><a href="#在通知中附加图片" class="headerlink" title="在通知中附加图片"></a>在通知中附加图片</h2><p>这个通知现在是基于文本.这没啥新鲜的! 让我们探索一下其他的特征,类似于在通知中展示图片.</p>
<p>在初始工程中,我已经绑定了一张图片:名为 <code>logo.png</code> .如果你没看见,可能是因为它隐藏在<code>NotificationsUI</code>组中了. 无论怎样,这张图片在初始工程中. 让我们来看一下怎么将它展示在通知中.</p>
<p><code>UserNotification</code> 框架为开发者提供了<code>UNNotificationAttachment</code>类,用来在通知中添加附件.附件可以是录音,图片和音频.他也支持许多文件格式. 更详细的信息可见看<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachment" target="_blank" rel="external"> Apple Developer Website</a></p>
<p>建立一个附件相当简单,像<code>UserNotifications.framework</code> 中的大多数任务一样. 我们只需要初始化<code>UNNotificationAttachment</code> 实例并把它加到通知内容中.更新 <code>scheduleNotification</code>方法并将下面的代码块插入在<code>request</code>变量前面.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if let path = Bundle.main.path(forResource: &quot;logo&quot;, ofType: &quot;png&quot;) &#123;</span><br><span class="line">    let url = URL(fileURLWithPath: path)</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        let attachment = try UNNotificationAttachment(identifier: &quot;logo&quot;, url: url, options: nil)</span><br><span class="line">        content.attachments = [attachment]</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;The attachment was not loaded.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码加载了logo图片的地址,转化为<code>URL</code>,然后用图片初始化附件.<code>UNNotificationAttachment</code>的初始化被标记为投掷条件, 所以需要一个<code>catch</code>block 解决错误.一旦创建好附件,将它加入<code>content</code>中.重新测试app.一旦应用加载,选择一个日期等待通知出现.</p>
<p><img src="/img/14764388175933.png" alt=""><br>天哪!快看,我们发送了一个带图片的通知.这是在iOS10中首先提到的新特性.这特别酷,但我想如果能加一个 “稍后提示”按钮允许用户暂时忽略这个提示会更好.</p>
<p>现在就做这个吧.</p>
<h2 id="用通知的方法添加一个提示"><a href="#用通知的方法添加一个提示" class="headerlink" title="用通知的方法添加一个提示"></a>用通知的方法添加一个提示</h2><p>按照API中设定的方式,在通知中加入一个功能有点复杂.然而,没什么是不能解决的.为了在通知中加入一个功能,需要使用<code>UNNotificationAction</code>和<code>UNNotificationCategory</code>.</p>
<p>首先,需要为功能定义一个类别<em>categories</em>. 只定义一个类别和一个功能.将下面几行代码插入<code>application(_:didFinishLaunchingWithOptions:)</code>方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let action = UNNotificationAction(identifier: &quot;remindLater&quot;, title: &quot;Remind me later&quot;, options: [])</span><br><span class="line">let category = UNNotificationCategory(identifier: &quot;myCategory&quot;, actions: [action], intentIdentifiers: [], options: [])</span><br><span class="line">UNUserNotificationCenter.current().setNotificationCategories([category])</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了一个动作一个类别,并用<code>UNNotificationCategory</code>登记这个类别.</p>
<p>可能,你会好奇为什么会存在类别. 他们用于不同的目的.将一个类别想象为一组功能,一旦创建,就能够在<code>UNNotificationContent</code> 中为通知添加一个类别, 这个类别中包含的所有功能都会展示在这个通知中</p>
<p>在这个demo中,类别里面只有一个功能; 但如果我们许多功能,将它们赋值给类会使他们都得到使用.这就是为什么苹果的工程师提供了<code>UNNotificationCategory</code>来管理通知的功能.</p>
<p>现在创建了一个功能一个类别并且登记了这个类别,使用它.更改创建<code>content</code>的这部分代码然后加入下面的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content.categoryIdentifier = &quot;myCategory&quot;</span><br></pre></td></tr></table></figure></p>
<p>这是告诉系统我们想在新的通知中使用<code>myCategory</code>.现在,编译并重新运行app看看发生了什么:<br><img src="/img/14764404214267.png" alt=""><br>太帅了! 我们的通知现在有了一个可爱的按钮.但是如果你点击这个按钮,它只是让通知消失了.剩下需要做的是编写相应这个动作的代码.</p>
<p><code>UNUserNotificationCenterDelegate</code>协议定义了通知回调的方法.所以,为了响应这个动作,让我们扩展<code>AppDelegate</code>来实现<code>UNUserNotificationCenterDelegate</code>这个协议.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension AppDelegate: UNUserNotificationCenterDelegate &#123;</span><br><span class="line">    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>方法会在用户选择一个动作后调用.你能通过已给的<code>UNNotificationResponse</code>的<code>actionIdentifier</code>获得用户选择的动作.让我们完成这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line"> </span><br><span class="line">    if response.actionIdentifier == &quot;remindLater&quot; &#123;</span><br><span class="line">        let newDate = Date(timeInterval: 900, since: Date())</span><br><span class="line">        scheduleNotification(at: newDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定制了一个当前时间之后的900秒(60s * 15 min)的新通知.最后,在 <code>scheduleNotification(at:)</code>方法中设置默认的通知中心的代理为<code>AppDelegate</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter.current().delegate = self</span><br></pre></td></tr></table></figure>
<p>现在重新运行这个app并定制一个通知来测试它们.当通知出现后,点击<code>Remind me later</code>按钮.<br>你会在15分钟之后收到另一个通知.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你喜欢这个关于用户通知框架的指导教程.在第二部分,我们会更深入的讨论通知并学习在通知中植入自定义的视图控制器.</p>
<p>你可以在Github上下载这份教程的<a href="https://github.com/appcoda/NotificationsUI-Demo" target="_blank" rel="external">demo工程</a></p>
<p><strong>声明</strong>: </p>
<ul>
<li>原英文文章来源于appcoda,本人仅作个人学习使用;若侵犯了原作者权益,立即删除</li>
<li>本人英语水平有限,文章中若有翻译上的错误,还请指正(<a href="&#x6d;&#x61;&#105;&#108;&#x74;&#x6f;&#58;&#x78;&#x69;&#97;&#113;&#x69;&#x6e;&#x67;&#x30;&#x38;&#x32;&#48;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#x69;&#97;&#113;&#x69;&#x6e;&#x67;&#x30;&#x38;&#x32;&#48;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a>)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/" data-id="ciznrq4160005eouxvufa32nh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-在Xcode7中使用Swift进行单元测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/在Xcode7中使用Swift进行单元测试/" class="article-date">
  <time datetime="2016-09-21T02:16:17.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/在Xcode7中使用Swift进行单元测试/">在Xcode7中使用Swift进行单元测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS 程序员经常需要debug自己的app,除非你是那种疯狂的程序大神,不然一定体会过几个小时几个小时找Bug最后却发现只是变量声明有误时候那种绝望的心情.比这更糟糕的是,几个小时也没找到Bug的原因. 无论你是程序新人还是开发过许多app的程序员,规范的编写单元测试能够使代码更可靠,安全且容易检查.</p>
<p>幸运的是,Xcode7和Swift支持单元测试.虽然写了单元测试并不代表程序没Bug, 它仍然是检查代码片段按预期执行并使debug容易些的相当有效的方法.</p>
<p>如名字那样,在单元测试中,会对指定的代码片段建立小的有针对性的测试函数,以确保每段代码都可以通过测试.如果测试通过,在函数旁边会出现绿色的标志.如果测试没有通过,无论失败原因是什么,Xcode都会将代码标记为失败.这表示你需要在代码中查找产生错误的原因</p>
<h2 id="Demo概览"><a href="#Demo概览" class="headerlink" title="Demo概览"></a>Demo概览</h2><p>首先,在<a href="http://www.appcoda.com/unit-testing-swift/" target="_blank" rel="external">这里</a>下载我已经创建好的工程,这是个简单的用数值和百分比进行百分比计算的应用.(exp:10% * 80 = 8)</p>
<p>这个百分比计算器相当简单.你主要看ViewController.swift这个文件, 文件中的代码注释的很通俗易懂.</p>
<p>工程中一共有5对关联关系:每一个关系对应界面上的一个UI元素,除标题外,还有俩个IBActions对应俩个Slider,每个IBAction的名称准确解释了这个方法需要执行的动作.当俩个滑块中的任一个改变时,百分比和数值跟着一起改变</p>
<p>此外,还有俩个简单的函数 <code>updateLabels()</code> 和 <code>percentage()</code> 用来执行你想要完成的动作:第一个函数更新滑块滑动时展示的数值,第二个函数传入俩个浮点型数值并返回百分比计算结果.</p>
<p>在模拟器中运行app. 刚开始时候,一切正常.但只要你开始更新数值,就会发现计算结果不对.为了找到这个Bug,我们可以将代码分成几个单元并分开测试以检查各部分是否按照预期执行. 这样做并不会解决Bug, 但能够缩小你找Bug的范围.</p>
<p><img src="/img/unit-test-demo-app.png" alt="unit-test-demo-app"></p>
<p>创建工程时,我选了默认包含测试文件.(如果你想手动添加文件,在iOS资源文件中依次点击 File &gt; New &gt; File &gt; Unit Test Case).此处,测试文件已经由Xcode建好,可以在 导航器的<code>PercentageCalculatorTests</code> 文件夹中找到<br><img src="/img/xcode-unit-test-option.png" alt="xcode-unit-test-option"></p>
<p>在<code>PercentageCalculatorTests.swift</code>文件中,类 <code>PercentageCalculatorTests</code> 里面已经创建了4个方法. 其中俩个是示例,可以删除(可以通过关键字<code>test</code>找到,并且在方法的序号列左侧有个方块形icon,名称以 <code>Example</code> 结尾).另俩个函数: <code>setUp()</code> 和 <code>tearDown()</code> 是专门用于测试的,在测试方法执行前后会依次调用.</p>
<h2 id="开始编写单元测试"><a href="#开始编写单元测试" class="headerlink" title="开始编写单元测试"></a>开始编写单元测试</h2><p>现在,将要开始写你的第一个单元测试!这个教程中,只测试类 <code>ViewController</code> . 我们需要在 <code>PercentageCalculatorTests</code> 添加一个实例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PercentageCalculatorTests: XCTestCase &#123;</span><br><span class="line">    var vc: ViewController!</span><br><span class="line">    </span><br><span class="line">    override func setUp() &#123;</span><br><span class="line">        super.setUp()</span><br><span class="line">        // Put setup code here. This method is called before the invocation of  each test method in the class.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func tearDown() &#123;</span><br><span class="line">        // Put teardown code here. This method is called after the invocation of each test method in the class.</span><br><span class="line">        super.tearDown()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 <code>PercentageCalculatorTests</code> 继承于 <code>XCTestCase</code>. 它包含了 <code>XCTest</code>框架. 每个<code>XCTestCase</code> 子类的实例负责测试工程中指定的一部分,例如一个特殊的特点.</p>
<p>因为 <code>setup</code> 在所有测试方法之前调用, 在<code>setup</code>方法中初始化 <code>vc</code> , 这样可以在每个测试方法中获得一个新的 <code>ViewController</code> 实例. 像下面的代码一样更新 <code>setUp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func setUp() &#123;</span><br><span class="line">    super.setUp()</span><br><span class="line"> </span><br><span class="line">    let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: NSBundle.mainBundle())</span><br><span class="line">    vc = storyboard.instantiateInitialViewController() as! ViewController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住所有的测试方法都以关键字 <code>test</code> 开头,否则Xcode不识别. 添加一个新方法 <code>testPercentageCalculator</code> 用来确认 <code>ViewController</code> 中的<code>percentage()</code>方法是否正常运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单元测试时要检查某一大块代码是否正常运行. 这一大块代码通常只需要几行典型的代码来测试,你只测试一个方法或函数. 单元测试通过给一部分代码提供一个入参,用这个执行代码,然后检查返回参数是不是与我们预期的相符合<br><img src="/img/Example.png" alt="Example"></p>
<p>比较我们预期结果是否正确这部分由 <code>XCTAssert</code>函数完成. 最简单的<code>XCTAssert</code> 函数为<code>XCTAssert(expression: BooleanType)</code>,需要传入BOOL表达式(exp: <code>5 &gt; 3</code>, <code>8.90 == 8.90</code> or <code>true</code>),函数返回真或假使得测试通过.</p>
<p>快来试试吧!首先,在方法<code>testPercentageCalculator()</code>中加入下面这行.然后,将鼠标移动到方法名左边的菱形块图标处,鼠标来回移动,icon变成一个可运行的icon然后点击开始测试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">        XCTAssert(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果运行顺利,测试通过,方法旁边出现一个绿色的对号.<br><img src="/img/unit-test-green-mark.png" alt="unit-test-green-mark"></p>
<h2 id="检查百分比计算结果"><a href="#检查百分比计算结果" class="headerlink" title="检查百分比计算结果"></a>检查百分比计算结果</h2><p>现在开始动真格了:测试<code>percentage()</code>方法. 通过 <code>vc</code>属性调用这个方法, <code>vc</code>是<code>ViewController</code> 的一个实例. 传俩个浮点值 50 和 50 ,用静态值<code>p</code>保存结果. 在这里, <code>p</code>应该等于25 (50 * 50% = 25),检查这个用例 <code>XCTAssert(p == 25)</code>并执行测试方法. 用下面的代码替换<code>testPercentageCalculator()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">        // Should be 25</span><br><span class="line">        let p = vc.percentage(50, 50)</span><br><span class="line">        XCTAssert(p == 25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过,意味着<code>ViewController</code> 的 函数 <code>percentage()</code>正常执行, 需要在其他地方找    bug原因. 可能在 <code>updateLabels()</code> 方法中</p>
<h2 id="检查Label"><a href="#检查Label" class="headerlink" title="检查Label"></a>检查Label</h2><p>添加一个新的测试方法 <code>testLabelValuesShowedProperly()</code> 用来检查Label上的内容是否正确.然后从ViewController中调用方法 <code>updateLabels()</code>,这次, 我们检查每个Label上的text属性和我们想要展示的东西是否相符.</p>
<p>记得你给 <code>XCTAssert</code>函数一个新的参数:字符串消息. 这样很方便,因为我们有多个(调用<code>XCTAssert</code>三次)需要完成检测的值. 如果测试不成功,这个消息会告诉我们到底哪里有问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testLabelValuesShowedProperly() &#123;</span><br><span class="line">        vc.updateLabels(Float(80.0), Float(50.0), Float(40.0))</span><br><span class="line">        </span><br><span class="line">        // The labels should now display 80, 50 and 40</span><br><span class="line">        XCTAssert(vc.numberLabel.text == &quot;80.0&quot;, &quot;numberLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.percentageLabel.text == &quot;50.0%&quot;, &quot;percentageLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.resultLabel.text == &quot;40.0&quot;, &quot;resultLabel doesn&apos;t show the right text&quot;)</span><br></pre></td></tr></table></figure>
<p>当你要执行这个方法时,你会得到<code>numberLabel</code>,<code>percentageLabel</code>,<code>resultsLabel</code>为<code>nil</code>的错误信息.这怎么可能?</p>
<p>这是因为我在Storyboard文件中创建的Label,因此他们仅在视图加载时调用一次.但是单元测试中<code>loadView()</code>方法永不执行, 所以Label没有被创建他们都是<code>nil</code>. 这个问题有一个解决办法是调用<code>vc.loadView()</code> ,但苹果在官方文档中不建议这样做,因为视图已经加载后再加载一遍可能会引起内存泄漏.</p>
<p>你应该获得<code>vc</code>的属性<code>view</code>,他会按顺序触发需要的方法,而不仅仅是<code>loadView()</code>.在<code>testLabelValuesShowedProperly()</code>中更新代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func testLabelValuesShowedProperly() &#123;</span><br><span class="line">        let _ = vc.view</span><br><span class="line">        vc.updateLabels(Float(80.0), Float(50.0), Float(40.0))</span><br><span class="line">        </span><br><span class="line">        // The labels should now display 80, 50 and 40</span><br><span class="line">        XCTAssert(vc.numberLabel.text == &quot;80.0&quot;, &quot;numberLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.percentageLabel.text == &quot;50.0%&quot;, &quot;percentageLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.resultLabel.text == &quot;40.0&quot;, &quot;resultLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用下滑线(_)默认一个常量名称,因为我们并不需要这个view而且也不会用到它.它只是告诉编译器”假装获得了这个视图并触发方法”</p>
<p>执行这个测试(如果你想执行测试类中的所有方法,你可以点击<code>class PercentageCalculatorTests</code>旁边的方形)<br><img src="/img/unit-test-demo-fail.png" alt="unit-test-demo-fai"></p>
<h2 id="修复Bug"><a href="#修复Bug" class="headerlink" title="修复Bug"></a>修复Bug</h2><p>如你所见,测试失败!具体的错误信息可以帮助我们确定可能引起Bug的原因. 结果告诉我们resultsLabel没有返回正确的text.让我们进到ViewController检查这些Label的是怎么被赋值的.在深入检查<code>ViewController.swift</code> 中的<code>updateLabels()</code>代码后,可以发现因为Bug的原因:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resultLabel.text = &quot;\(rV + 10)&quot;</span><br></pre></td></tr></table></figure>
<p>应该为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resultLabel.text = &quot;\(rV)&quot;</span><br></pre></td></tr></table></figure>
<p>更新代码然后再次测试.万事顺利!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个教程中,学习了Xcode中的单元测试以及单元测试怎么帮助你在代码中找到Bug.除了减少Bug,单元测试能用来性能测试和异步测试. 其他吸引人的部分是UI测试,能通过记录动作在app中还原真实场景的表现.如果这听起来很有意思,你真该好好看看<a href="https://developer.apple.com/videos/play/wwdc2015-406/" target="_blank" rel="external">这部分关于UI测试的视频</a></p>
<p>完整代码,可以在<a href="https://github.com/appcoda/SwiftUnitTestDemo" target="_blank" rel="external">这里下载</a></p>
<p><strong>原文链接</strong>: <a href="http://www.appcoda.com/unit-testing-swift/" target="_blank" rel="external">http://www.appcoda.com/unit-testing-swift/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/在Xcode7中使用Swift进行单元测试/" data-id="ciznrq42x000ieouxdl0j30ig" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/27/当我们吵架时吵的是什么/">当我们吵架时吵的是什么</a>
          </li>
        
          <li>
            <a href="/2017/02/24/哪些引起话引起你的强烈共鸣/">哪些引起话引起你的强烈共鸣</a>
          </li>
        
          <li>
            <a href="/2017/02/23/没有对比就没有伤害/">没有对比就没有伤害</a>
          </li>
        
          <li>
            <a href="/2017/02/22/为什么争执/">为什么争执</a>
          </li>
        
          <li>
            <a href="/2017/02/21/一场大雪/">一场大雪</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Summer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>