<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Summer Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Summer Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Summer Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Summer Blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="Summer Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Summer Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-习惯" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/20/习惯/" class="article-date">
  <time datetime="2016-12-20T01:49:50.000Z" itemprop="datePublished">2016-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/20/习惯/">习惯</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">自己写东西的时候，如果妈妈在旁边放电视，会戴上耳机尽量让音乐声音超过电视剧；可是一个人在家，房间里面冷冷清清，不会被任何人打扰的时候还是会听音乐。前者叫做甜蜜的负担，后者称为孤单的狂欢。</font>

</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1."></a><font color="#B96969" size="5.0" face="黑体">1.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;这是想要坚持下来的第四天，为了写文字的时候不只胡乱看文章凑字数，在家到地铁这段路上看了一些现在比较流行的内容APP上作者的文章，然后自己有一点迷茫。别人是怎么一气呵成的写出不粘不腻清爽干净的文章呢，还能够吸引读者继续读下去，并且在读完之后若有所思？有一天，希望我也能成为这样的作者，不为这个世界的千千万万，只为那个被我吸引的你，哪怕这样的人只有一个。<br><br>&nbsp;&nbsp;前俩天有个很火的宣传，&lt;得到&gt;APP付费10万购买知名大V马伯庸的一篇文章，免费在应用上让读者看，只是拟定了一份好像不是很严肃的协议，希望看到马的文章的朋友们“仗义”相助，将应用分享给身边5个人。与平时造势营销不一样的地方在于，这一次的得到团队的营销不仅仅没有引起大家的反感，反而很积极地去分享和传播。互联网带来的便利的同时，也带来了爆炸的信息，我们每天好像很繁忙的浏览于不同的软件之间关心国家大事，国际要闻。可是一个转身，便会忘记上一秒的记忆。时间被分成了无数个碎片，好像很勤奋的在吸收营养，到最后只是呼吸了一肚子雾霾。明星们一个又一个不断刷新底限的炒作，让人觉得疲惫，平时寡言少语的我们在屏幕另一端看见各种明星的八卦时候，所有的道德都展现出来了，是德行不好的人都不上网还是上网的人都有优良品德？<br><br>&nbsp;&nbsp;马先生的那篇文章在被得到购买版权之前，有一段小故事。他老人家的&lt;显微镜下的大明&gt;之前一直在网上连载，先生寻经考据查阅了很多相关的历史书籍和资料，最终才完成了那篇3万字左右的文章。完成文章耗费了不少的时间，可由于文字数不多不少、不上不下不能作为单独的书籍出版，又不能单独查阅，所以先生也只是将文章放在网上任其自由生长。这件事被’和菜头’知道后，大为恼火，他认为这样优秀的文章不应该被埋没，并认为应该有人为他付费。他让先生将网络上的文章删除，并愿意为先生找到购买版权的人，于是有了后面的事。<br><br> &nbsp;&nbsp;我特别赞同’和菜头’的做法，而且也愿意为好的知识付费，不仅对于作者的尊重也是对自己的付出点赞。如果越来越多的读者和作家能意识到知识产权的重要性，一定会有更多的优秀文章被大众熟知。这一点，在我们这代身上，已经有了很好的改正，已经能够看到知识创业在当下的可行性。好东西应当光芒万丈。</font>

<h3 id="2"><a href="#2" class="headerlink" title="2."></a><font color="#B96969" size="5.0" face="黑体">2.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;良好的知识体系跟从小养成的学习习惯息息相关。好多学霸，学东西能够一通百通，自成一家；而很多像我一样的学渣，理解问题像是掰玉米的狗熊，掰一半丢一半。可又因为习惯的养成往往是反人性的，大脑不愿意主动回忆起这些东西，比起买买买的爽，学习新知识简直是个灾难。有国外的同学帮我们找到了好的顺应大脑舒适区的办法，让习惯的养成变得简单一点。《习惯的力量》里面说好习惯难继续执行，是因为人们往往在刚开始做的时候，设定了太高的门槛，比如要一个月瘦20斤，每天游泳一小时，一个月英语过专八等；如果能够把目标变得简单易行，随手可做，那么会很容易坚持，将一个月瘦20斤调整为每天5个俯卧撑，每天游泳一小时改为一天跑步一公里，1年以后会有意想不到的成就，作者称他们为微习惯。<br><br>&nbsp;&nbsp;提到微习惯，网上有很多人将扎克伯格的个人计划作为例子：2011年，每天扎领带上班；2014年学习汉语，于是每天和中国员工交谈，2015年时候已经能够用汉语演讲；每天想想身边令自己感动得事，其中他对妻子的感谢视频尤其令人感动；2015年，要恢复每天写代码的日子；每周读一本书，在年底时，Facebook上他一共推荐了22本书；（时间和计划可能有出入，后面看到准确的列表重新更新）等等。很多人在看到他的计划时候时，可能都会觉得不屑于去做，这也是需要我们反思的地方。<br><br>&nbsp;&nbsp; 想想自己每年的计划，简单粗糙，可操作性不强。今年要去旅游，要会化妆，要看7本书，要完XX指标。年末数列表，这些计划好像都完成了，可是又好像没完成，没有丝毫的成就感。17年将至，新年的计划要求和扎扎的一样明确也是有难度，可还是要向他们看齐么。把学会化妆改为学会化自然清透的裸妆，每周至少有2天是带妆出门的；看7本书换成每俩周看一本书，在书上对值得反复回味的地方做出标记，方便下次阅读。能够在几分钟之内解决的事情，不要记在todolist上面始终占用大脑的内存空间，大脑容量有限，始终记得一件没有完成的时会占用资源，使其不能得到合理利用和释放。</font>

<h3 id="3"><a href="#3" class="headerlink" title="3."></a><font color="#B96969" size="5.0" face="黑体">3.</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp; 说来惭愧，文中提到的《显微镜下的大明》和《习惯的力量》自己都还没有看过，明天先把’大明’看了，在对先生的文章写出读后感悟。这样只是看了别人的总结实行拿来主义，不是个好行为，对于文章里面出现的内容应当是自己仔细查阅过得才能够写出来，这才是对文章负责。</font>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/20/习惯/" data-id="cizgqoil7000duouxa3xkz377" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-生活在别处" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/19/生活在别处/" class="article-date">
  <time datetime="2016-12-19T02:25:48.000Z" itemprop="datePublished">2016-12-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/19/生活在别处/">生活在别处</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">小的时候听大人们说谁家的小孩又乖又聪明，学习好，品质好；长大以后看别人的朋友圈经常能看见好车好房好身材，没有工作压力，没有经济拮据；我们的向往的生活永远在别的地方。</font>

</blockquote>
<h3 id="怎么理财"><a href="#怎么理财" class="headerlink" title="怎么理财"></a><font color="#B96969" size="4.0" face="黑体">怎么理财</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;理财类的初级入门读物上都说：你不理财，财不理你。报着让财理自己的端正态度，阳光还不错的周日早晨听了简七的极简理财课。对我这样一窍不通的菜鸟级新人，虽然老师的课讲得通俗易懂，但对于我自己可操作的内容有限。课程中提到了俩个概念，算是给自己在以后的道路上打个基础。课程中老师做了个例子：用5w投资，2005年开始进行资产配置，每年重新对资产分配保证资产的动态平衡，用数据回测的方式在其2015年10年时间里面刨去汇率和手续费等等因素，15年的投资金额会变为19w。虽然只是数据回测的方式模拟了10年的交易，及时在真实操作中也是可行的。可惜自己除了没有股票账户，也没有多余的时间和精力进行这样的配置尝试。<br><br>&nbsp;&nbsp;之前也关注了其他的公众号和关于理财的课程等，不知道是什么原因，总不能将理财这个东西完全跟自己的生活完全做个关联，看来时候还没到。前段时间家人生病，让自己对保险多用了好几分心思。对于一个普通家庭，即使有医疗保险作为保障，大病面前还是觉得无奈和苍白，经济快速发展的同时，国民素质也在不断下降。不断爆出的食品安全问题，让人早已见怪不怪，我们开始关注的从什么不能吃，变成了什么可以吃。黄瓜上的黄花要用药水泡，才能在出售给来百姓时候卖个好的价钱；牛肉用化学黏合剂黏在一起，以次充好；三聚氰胺提高婴幼儿奶粉中的蛋白质含量等等。<br><br>&nbsp;&nbsp;树欲静而风不止，子欲养而亲不待。我们忙着赚钱，忙着生活，到了能够享福的年龄却还要忙着生病。疾病总是最公平，无阶级，无权贵。重疾面前人人难逃一死。应运而生的重疾保险也在最近几年里面火了起来。作为一个怕死的人，刚知道这种保险的时候，有点小兴奋，而作为一种长期的保险，这个险种的保费动辄10几万。关注了好一段时间都没有买，因为不懂也不知道意义究竟有多大。看了一份简七推荐的保险清单，里面详尽的介绍了各个年龄层需要购买的险种，看完受益良多。人这一辈子想要保全自己，需要的保险至少要7份，前路任重而道远。</font>

<h3 id="请你原谅我"><a href="#请你原谅我" class="headerlink" title="请你原谅我"></a><font color="#B96969" size="4.0" face="黑体">请你原谅我</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;情感类节目中，用亲情和故事总能赚足观众的眼球，每次看到这样的节目，我的小金豆啪嗒啪嗒的跟着主人公的心痛而动。一位父亲满含泪水希望读懂儿子心里的想法，儿子5岁时候，由于夫妻感情破裂，选择了各奔东西，还在幼儿园的儿子被母亲没有任何通知的前提下带走，一别11年，再相见，父子难回从前；儿子喜欢网游，宁愿坐在电脑前和’战友’征途新世界，都不想抬头看老爸一眼；爸爸满心愧疚的对儿子告白，儿子却只是冷冷的看着。<br>&nbsp;&nbsp;幸福的家庭是相似的，而不幸的家庭各有各的不幸。父母不负责任的决定，受伤的却总是无辜的孩子。童年缺失的爱长大以后能够弥补么？还好，儿子只是不想跟别人说话，心里能暖起来的。过去的一些不开心经常会随着时间一起成长，他们从来不会消失不见，只是我们学会了怎样去更好的和它共处。儿子说：“我能理解你心里的想法，知道你想做什么；但对于我来说，我觉得你是我爸这就足够了。对于我来说你只是个不太熟悉的陌生人，你不能因为称你为父亲，就可以要求我做你想要而我不喜欢的东西，然而你并不理解我想要什么。”相似的处境，能让我对这个儿子的理解多一些，对于他的冷漠反而不会过分苛责。我觉得他只是把自己包在了一个壳里面，把曾经所受到过的冷暴力用不一样的方式还回去，即使那些伤害并不是父亲带来的。<br>&nbsp;&nbsp;古语说解铃还须系铃人，可有些时候，那个系铃铛的人早已经不在了。我想，我们还是应该对身边的人多一些善待，因为谁都不知道对你微笑的那副脸庞曾经经历过什么。对那个儿子，相信他一定也会知道，成长过程中的那些伤带来的影响不会仅仅只有影响。在给予我们不开心的那些人面前，回击他们的方式要么是以数倍的力量反击回去，要么宽容或者原谅，哪一种都需要漫长的时间和心智的积累。希望你好。</font>

<h3 id="看书才能写出文章来"><a href="#看书才能写出文章来" class="headerlink" title="看书才能写出文章来"></a><font color="#B96969" size="4.0" face="黑体">看书才能写出文章来</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;我站在桥上看风景，看风景的人在桥上看你。我们羡慕大理客栈老板的悠闲，羡慕辞了稳定工作去开自己马场的美女老板，可是不知道老板也为淡季客源发愁，美女为每天马粪烦恼。他们的生活你不一定真的想要，你的生活也许还好。多读读书，别在看着人家股票牛市赚的盆满钵满时候，还不理解什么叫做做T；别在人家研究虚拟货币的时候，才开始接触支付宝。保持对这个世界的好奇，不能行万里路，也从别人走过的经验里面领悟一些知识。你见了哪个富豪取了一位只有白腿没有脑袋的太太？</font>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/19/生活在别处/" data-id="cizgqoin80016uouxsjx6gx0p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-艰难的第二记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/18/艰难的第二记/" class="article-date">
  <time datetime="2016-12-18T02:28:12.000Z" itemprop="datePublished">2016-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/18/艰难的第二记/">艰难的第二记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#BA8072" size="3.0" face="黑体">一个好习惯的养成,大概需要21天;如果没有一个明确的目标,没有足够的动力,21天里的每一天都是个劫难(=@__@=)。这么想来，之前自己坚持每天写东西的小习惯，相对于我这个越来越懒的人来说略有些伟大。好在完成一件是之后能够带来持续的满足感和自信心，而这也许会是自己能够坚持下去的最好原因。</font> 

</blockquote>
<font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;说笑之外，现在的每日一记和之前的日记有一些区别，从前主要记录每天的心情感受，所想与所得，简单来说是一个女儿家的小情切。而现在希望每天写下的东西不只是面对自己，而是面对有天可能看到文字的所有读者。这样写的东西会更负责任，思想的更周全。也能每天倒逼自己做出更多输入。为了让这一篇写起来不会像倒饺子的茶壶，白天时候故意做了一些功课，争取能够在1小时完成2500字左右，这作为今天的目标。</font>

<font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;难得清闲的周六，看了俩档中央卫视的节目《挑战不可能》、《和全世界做生意》。 今天的文章，想聊聊自己对于’专业性’的看法。</font>

<h3 id="挑战不可能"><a href="#挑战不可能" class="headerlink" title="挑战不可能"></a><font color="#B96969" size="4.0" face="黑体">挑战不可能</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;‘不可能’节目里面有位来自非洲的小伙，他的花式足球现在已经成为了巴黎50个必去景点之一。他的挑战项目是天梯颠球，作为观察者审视别人的挑战时，经常会低估项目的难度。天梯共70阶，最高处与地面所成夹角为65°。仔细想来，脚上没有足球动作，一节一节毫无间断的爬上去对于一个体力正常的年轻人也不容易。而伊娃需要背对台阶脚颠足球倒着跳到最高点，才能算挑战成功。第一次，35阶处足球飞走；没有一秒间歇，开始了第二次，50阶处又败；节目的嘉宾说那个位置恰好是和更上一级衔接的地方，所以阶梯会变窄（天梯是伸缩式的），他俩次失败都没让自己觉得意外，因为这个挑战无论是体力还是耐力都是个极大极大的考验。短暂休息开始的第三次，才是真的令人觉得无限遗憾又深感惋惜的一次，这也是自己头次对足球项目报这么大的兴趣，也许是由于男女天生运动神经构造不一样，我始终不能理解十多个身强体壮的男人对一个球滚来滚去的兴趣和男人不能理解我们对于逛来逛去却什么都不买是一个道理。伊娃在第69级，大家已经准备好了为他的成功欢呼鼓掌的时候，球又飞走了，李昌钰博士说他的头已经到了70那里，所以算是另一种成功。失败时候没有流出的眼泪，偏偏在听到安慰与鼓励时流出来了。由于家中经济原因，在本应该读专业学校的时候，伊娃选择了撑起家中的担子放弃了求学之路，而今登上大屏幕，屏幕那一面仍然有许多没有好条件的兄弟姐妹邻里乡亲，希望他能成功，可是最后一刻，偏偏没有得到渴望的结果。<br><br>&nbsp;&nbsp;我不知道他每一级向前的背后有多少汗水，受过多少奚落，忍受了多少别人不能忍的痛苦。拼搏的路程常有一些相似的地方，他的泪水能唤起自己心里的共鸣，是因为在那个憨厚的小伙身上看到了一些自己和身边许多人的影子。我们生活的年代，物质并不匮乏，已经很少有人会因为吃不饱饭，穿不暖衣而饿死。按照马斯洛的需求理论，现在人追求的满足很大一部分都属于精神层面，可我们却多了越来越多的焦虑和抱怨，虽然每个时代都有相应的烦恼，若是能够在这些烦恼的间隙学学伊娃身上的坚韧，生活也许会变得阳光很多。哪位名人说的：有裂缝的地方，才能照进来阳光。论花式足球，伊娃可能没有受过专业训练，但这不阻碍我对他‘专业’表演的敬佩。</font>

<h3 id="在全世界做生意"><a href="#在全世界做生意" class="headerlink" title="在全世界做生意"></a><font color="#B96969" size="4.0" face="黑体">在全世界做生意</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;另一档节目中的一段讲的事德清母女在甘肃仁多玛开了围巾工坊“诺乐”。藏语中，诺乐是牦牛的意思，同时寓意吉祥。无论在电视节目中，还是生活中遇到的（寥寥无几）外国友人几乎总是能给人一副乐观阳光，积极向上的印象，而且越是优秀的高材生越能够以心怀天下为己任，最后呈现出来的结果却都是我这样一切’朝钱看’的人想要达到的。有时候，会反省自己是不是因为太急功近利了，才把生活过得好像一团乱糟糟，真的有那么不堪么？德清说她最开始想要留在那个海拔3000米的小村庄，并不是为了赚钱，只是希望帮助当地的藏民搭起一座和世界沟通的桥梁，帮那里打通和世界的贸易，让藏民们过上富足一些的生活。节目中的德清，脸上有俩团高原红，我猜想，在陆地生活的时候她一定是个很美丽的女子。当她的愿望稍微实现一些，订单量变大，工坊需要扩张的时候，需要习惯了自由自在的牧民们加班加点完成客户的需求。有些人开始说她去仁多玛只是为了赚钱，为了满足自己的愿望。最难得考验好像常会在生活美满的时候出现，特别想她能够挺过难关，她的母亲也说“做事情并不是为了要别人赞同自己，而是自己认为正确，就去做”。虽然年龄相仿，无论能力还是胸襟她都该是高了自己好几个等级，总有许多人是这样，他们比你优秀比你天分好，可是还比你努力。在围巾的领域中，能够以自己的视角和产品立足，除开故事本身，和她对于市场的专业判断有很大关系。有一天，我们也会成为这样的人。</font>

<h3 id="偶尔得喝鸡汤"><a href="#偶尔得喝鸡汤" class="headerlink" title="偶尔得喝鸡汤"></a><font color="#B96969" size="4.0" face="黑体">偶尔得喝鸡汤</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;说一万句很有道理的话，都没有践行一件很简单的事来得更有说服力，要做个’专业’的人。</font>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/18/艰难的第二记/" data-id="cizgqoio4001guouxpvb0f2zn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-发烧以后" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/16/发烧以后/" class="article-date">
  <time datetime="2016-12-16T09:27:06.000Z" itemprop="datePublished">2016-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/16/发烧以后/">发烧以后 ^_^</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <font color="#696969" size="3.5" face="黑体"><br>&nbsp;&nbsp;昨天夜里开始浑身发冷,在被窝里面缩成一团,只觉难受,并没想到会发烧.晨起,收拾完毕,一切照旧,去公司上班,这一天的噩梦开始了,在地铁上的时候只是头晕,下了地铁走路开始吃力。在公司趴一小时，冷到不能自已。打车回家。测体温—38.7°，记忆里面已经很久没有发烧了，何况是这么高的温度，心里竟有一丝丝窃喜，这要是发到朋友圈，应该能得到好几个赞。在床上瘫了一整天，晚上9点体温达到了38.9。睡了一晚，烧退了，胃开始疼。<br><br>&nbsp;&nbsp;自己也不清楚，身体上体现出来的种种不适，到底是因为真的病了，还是这段时间来一直紧绷的情绪出现了物理反应。近一个月自己的精神状态始终在一个不可控的状态。严重的时候，好像胸中有团怒火，嘶吼着要从头顶喷涌而出。遇到了超出解决范围的问题，也不知道该找个什么样的发泄口，然后抑郁堆积在心里，由土堆变成了丘陵。除了不断感受到自己的无助，我为自己做的只有不停地慌张和焦虑，像生活明天要停止了一样。<br><br>&nbsp;&nbsp;11月份时候，听了一场李笑来老师的网络直播课，一小时的直播有60多万人参与。因为自己书读的太少，吸收的知识有限。昨天，又听笑来老师推荐的“普通人快速崛起的10大狠招”，俩场讲座里面都提到的每日写作这个观点，让心里捡起写日记的小火苗燃了起来。谨此，将猫老师讲座里面的一些感受记下来，为每日一次开个头。</font>

<h3 id="一、个人品牌"><a href="#一、个人品牌" class="headerlink" title="一、个人品牌"></a><font color="#B96969" size="4.0" face="黑体">一、个人品牌</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;厂家都讲究品牌效应，酒香不怕巷子深的道理没有错，然而不能作为这个互联网时代的普适定律。如果能够找到自己喜欢并愿意坚持的事情作为突破，打造出个人品牌，一定会有很多意想不到的收获。iOS开发是要求有一定的经验和教育背景的工作，但是Apple一家独大的局面加上现在市场上供小于求的供应关系,自己不出色的硬件实力，会经常让人陷入一种绝望而不能自拔。我开始发现周围的人都在使用和安装微信时，智能手机还没有完全普及，许多人使用它“摇一摇”的功能来方便快速的和陌生人交往，既新鲜又好奇。而发展至今，微信已经变成了熟人社交圈里面岿然不动的一座大山，有很多科技类和新媒体网站都会说，能在社交领域有建树，需要选一条和微信不一样的路。偶尔午后吃完饭，会和三俩个跟自己一样的程序员屌丝讨论一下民生大事，科技发展等等略吹牛逼的话题。我们许多人都认为：腾讯成就了微信，微信也成就了腾讯。 天下熙熙皆为利来，天下攘攘皆为利往。微信的成功有他的独特和不可替代性，张小龙的成功之路也不能复制。这个世界唯一不变的是变化。</font>

<h3 id="二、读书的质量"><a href="#二、读书的质量" class="headerlink" title="二、读书的质量"></a><font color="#B96969" size="4.0" face="黑体">二、读书的质量</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;《如何阅读一本书》这本书里面，贯穿始终的一个观点是：书读的数量不在多，而在于精。猫老师却认为读书首先要量大，这样才能够在遇到一件事或者一个观点时从大量的书里面找到可以为自己佐证的论点。俩种观点，各有各的道理。能够保持大量又高质的阅读能够结合二者精华，但对于像我这样的读者确实有些难度。古人云“鱼和熊掌，不可兼得”。所以我想在开始没有掌握读书的方法和技巧的时候应该向《阅读》里说的，将阅读分为几个层次和几个大步。能够熟练运动这些方法时，从各类书籍中汲取自己需要的，大量的翻阅书籍是比较适合自己的。开卷有益，毋庸置疑的是，每个走到了自己理想状态的人，一定读过许多书。<br>&nbsp;&nbsp;这让我想起那个开除我的女领导。作为清华建筑系的女高材生，她虽然有点暴躁（这点我和她hin相似），可在许多方面都有自己独到的见解和思维方式。虽然把我开除这件事，令自己心碎，以至于在现有公司呆了俩年仍然时时刻刻担心自己做的不好，但还是会偷偷的通过各种方式关注她。通过各类自我介绍，以及相处的短暂的俩个月，我知道她从小已经读过许多许多书，上知天文地理，下知宇宙哲学；会溜冰，会画画，养过狼，养过狗，能文能武，能缩能伸。简直是自己梦里的样子，可这个梦里的样子跳到现实来，居然把自己开除了，说明现实中的我还有许多需要修炼的地方。她能快速阅读一本书，并在书中找到自己想要看的东西，单这一点是我要很久才能学来的。每一笔经历都会成为财富，我在心里感谢过她很多次，也希望自己早一天变成理想状态。</font>

<h3 id="三、采访"><a href="#三、采访" class="headerlink" title="三、采访"></a><font color="#B96969" size="4.0" face="黑体">三、采访</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;猫老师说，快速学习的方式之一是采访各个行业的顶尖人才。以自己当前这个身份采访这个词，可能有些夸张了，别说采访了，见都见不到。可这的确为一个好办法，我采访不到，但各个知名的主持人能见到啊，看他们的采访又能省去自己找人的时间，又能够学习，一箭双雕。为自己的机智点个赞。名人自传也是个学习的好途径，这又回到了上一点，好好掌握读书的方法。</font> 

<h3 id="四、知识分享"><a href="#四、知识分享" class="headerlink" title="四、知识分享"></a><font color="#B96969" size="4.0" face="黑体">四、知识分享</font></h3><font color="#696969" size="3.5" face="黑体">&nbsp;&nbsp;彻底掌握一门知识的最好办法是讲给别人听。这个观点听很多人说过了，可平时见不到那么多人，好在有可替代的办法：把所学写成文章整理出来，在写文章的过程中会将思路理顺打通。写作这件事，难在了用心把东西写好并且不会让别人读起来觉得恶心。除此之外，需要有足够的精力配合。我关注了许多微信公众号，有很多公众号作者特别勤劳，每天都有产出，且篇篇都有觉得很有道理，日常生活中发生的小事经过他们的笔变得有趣生动，所谓妙笔生莲花，应该就是这意思。可知识分享，首先得有知识，提笔脑空，分享什么呢？于是又扯出了俩个点：1.知识丰富 2.提笔成章。贫瘠的土壤尚且种不出肥沃的土地；怎么能指望空空的脑袋，给别人说些令人信服的观点。<br><br>&nbsp;&nbsp;上面的几个点是听猫老师讲座中有感想的一部分，将讲座的听后总结作为日日记的第一篇，因为猫老师本人是每日写作的受益者；又因为他的讲座是付费直播，我想对得起自己付出的每一分钱；还因为自己之前喜欢将每天发生的事情写下来，希望能将这个事情重新捡起来，即使不能够从中受益，每天写点东西也能让每天孤单的生活丰富多彩。老师们要求每天3000字，今天初试，2000多字写了3个多小时，惊讶于自己笔下没墨，也有点担心工作后没有这么多的时间和精力。但我必须把这个事情坚持下来，至少得回到高中时候的写文字水平吧？！3个小时写这么点，都对不起这大好的时间，(；′⌒`)</font>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/16/发烧以后/" data-id="cizgqoilb000fuouxv86dmf22" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-播放本地音频" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/24/iOS-播放本地音频/" class="article-date">
  <time datetime="2016-10-24T10:05:02.000Z" itemprop="datePublished">2016-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/24/iOS-播放本地音频/">iOS 播放本地音频</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<font color="#0099ff" size="3" face="黑体">产品同学想要实现一个功能:用户完成某个任务时,进行语音提示. 于是这个简单的要求,折磨我3天(；′⌒`), 实践证明,开发之前的充分调研能够少走弯路; 开发经验也的确能够缩短开发时间</font>

</blockquote>
<h2 id="那些自己尝试-zou-过-guo-的-de-方-wan-法-lu-💨"><a href="#那些自己尝试-zou-过-guo-的-de-方-wan-法-lu-💨" class="headerlink" title="那些自己尝试(zou)过(guo)的(de)方(wan)法(lu)💨"></a>那些自己尝试(zou)过(guo)的(de)方(wan)法(lu)💨</h2><ul>
<li>定时声音推送(UILocalNotification), 类似闹钟的功能,到了指定时间后,响起一段音乐. 然而这样做的问题在于,并不知道用户什么时候做任务; 且任务切出界面后,任务需要结束. 本地通知不能满足要求ˇˍˇ ,放弃</li>
<li>AVAudioPlayer播放本地音频, 这个好,棒极了,开发完之后,发现产品需要音乐能够后台配置(论读懂需求的重要性),且音乐时长也许会超过30s. 再弃</li>
<li>最后选择了AVPlayer</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1.AVAudioPlayer和AVPlayer声明对象都需要设置成全局变量<br>2.AVAudioPlayer和AVPlayer都需要引入AVFoundation框架<br>3.iOS9引入了新特性App Transport Security (ATS),需要在plist中添加权限. 添加方式:左键Info.plist选择open with source code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;</span><br><span class="line">	&lt;true/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>
<h2 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h2><p>1.加载音频文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//播放本地音频</span><br><span class="line">  NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;独角戏&quot;  ofType:@&quot;mp3&quot;];</span><br><span class="line">  NSURL *sourceMovieUrl =  [NSURL fileURLWithPath:filePath];</span><br><span class="line">  //播放网络音频</span><br><span class="line">  //NSURL *sourceMovieUrl = [NSURL URLWithString:urlString]</span><br></pre></td></tr></table></figure>
<p>上面的代码中本地音频和在线音频的主要区别在于路径的不同:本地路径使用<code>[NSURL fileURLWithPath:本地音频路径]</code>,在线音频使用<code>[NSURL URLWithString:在线音乐地址]</code></p>
<p>2.创建AVPlayer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AVAsset *movieAsset = [AVURLAsset URLAssetWithURL:sourceMovieUrl options:nil];</span><br><span class="line">self.timerPlayerItem = [AVPlayerItem playerItemWithAsset:movieAsset];</span><br><span class="line"></span><br><span class="line">//这是用来支持后台播放的</span><br><span class="line">AVAudioSession *audioSession = [AVAudioSession sharedInstance];</span><br><span class="line">NSError *setCategoryError = nil;</span><br><span class="line">[audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;setCategoryError];</span><br><span class="line"></span><br><span class="line">[audioSession setActive:YES error:nil];</span><br><span class="line">if (setCategoryError) &#123;</span><br><span class="line">    NSLog(@&quot;这里有问题 %@&quot;,setCategoryError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.timerPlayer = [[AVPlayer alloc]initWithPlayerItem:self.timerPlayerItem];</span><br></pre></td></tr></table></figure>
<p>有了音频文件的路径,剩下的就是将音乐播放出来了.上面的代码有俩个作用:1.创建AVAudioSession使得播放器支持后台播放 2.创建音频播放器. 其中代码中用到的<code>AVAsset</code>是个抽象类,不能够单独使用.</p>
<p>3.播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.timerPlayer play];</span><br></pre></td></tr></table></figure>
<p>如果仅仅是播放音乐,上面的代码就足够了,但往往播放音乐后还需要许多操作,比如音乐完成后界面需要提示啊,音乐播放进度等等. 于是就有了下面的监听</p>
<p>4.添加和移除监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//添加监听</span><br><span class="line">- (void)addObserverForPlayerItem</span><br><span class="line">&#123;</span><br><span class="line">    [self.timerPlayer.currentItem addObserver:self forKeyPath:@&quot;status&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    [self.timerPlayer.currentItem addObserver:self forKeyPath:@&quot;loadedTimeRanges&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    //添加音乐播放完成的通知</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(itemDidFinishPlaying) name:AVPlayerItemDidPlayToEndTimeNotification object:self.timerPlayer.currentItem];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除监听</span><br><span class="line">- (void)removeObserverForPlayerItem</span><br><span class="line">&#123;</span><br><span class="line">    [self.timerPlayer.currentItem removeObserver:self forKeyPath:@&quot;status&quot;];</span><br><span class="line">    [self.timerPlayer.currentItem removeObserver:self forKeyPath:@&quot;loadedTimeRanges&quot;];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:AVPlayerItemDidPlayToEndTimeNotification object:self.timerPlayer.currentItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码利用KVO属性监听了<code>status</code>和<code>loadedTimeRanges</code>属性,并添加了<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知;<code>status</code>是对player的状态的枚举值,当<code>status = readytoplay</code>时候才能播放资源或进行其他的界面处理,<code>loadedTimeRanges</code>的属性监听可以获得当前资源的缓冲进度.下面是对属性监听后的操作示例和收到<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知后执行的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;status&quot;]) &#123;</span><br><span class="line">        int status = ((NSNumber *)change[@&quot;new&quot;]).intValue;</span><br><span class="line">        if (status == AVPlayerStatusReadyToPlay) &#123;</span><br><span class="line">            //进行相应的界面处理</span><br><span class="line">            NSLog(@&quot;hehehheeh&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;else if ([keyPath isEqualToString:@&quot;loadedTimeRanges&quot;])&#123;</span><br><span class="line">        NSArray *array = self.timerPlayer.currentItem.loadedTimeRanges;</span><br><span class="line">        CMTimeRange timeRanges = [array.firstObject CMTimeRangeValue];</span><br><span class="line">        float startSeconds =  CMTimeGetSeconds(timeRanges.start);</span><br><span class="line">        float durationSeconds = CMTimeGetSeconds(timeRanges.duration);</span><br><span class="line">        //获取缓冲时间</span><br><span class="line">        float bufferTime = startSeconds + durationSeconds;</span><br><span class="line">        NSLog(@&quot;%f&quot;,bufferTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)itemDidFinishPlaying</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;终于完事了&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了上面这些代码,基本能够满足产品对于播放音乐的需求了.但是考虑到配置的提示音并不长,所以领导希望音频缓存到本地后再进行播放,所以接下来需要下载音乐文件</p>
<h2 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h2><p>1.设置本地文件的存储路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 下载后的音频存放路径</span><br><span class="line"></span><br><span class="line"> @param fileName         文件名称</span><br><span class="line"> @param isFileExistBlock 回调</span><br><span class="line"> */</span><br><span class="line">- (void)audioFilePath:(NSString *)fileName</span><br><span class="line">          isFileExist:(void(^)(BOOL isExist, NSString*savePath))isFileExistBlock</span><br><span class="line">&#123;</span><br><span class="line">    NSString *cachePath=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    </span><br><span class="line">    NSString *savePath=[cachePath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;audio_%@&quot;,fileName]];</span><br><span class="line">    NSLog(@&quot;%@&quot;,savePath);</span><br><span class="line">    </span><br><span class="line">    //首先判断当前路径是否存在</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    BOOL isPathExist = [fileManager fileExistsAtPath:savePath];</span><br><span class="line">    if (isPathExist)</span><br><span class="line">    &#123;</span><br><span class="line">        //存在相同的文件</span><br><span class="line">        if (isFileExistBlock) &#123; isFileExistBlock(YES, savePath); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        if (isFileExistBlock) &#123; isFileExistBlock(NO, savePath); &#125;</span><br><span class="line">        //判断当前路径下文件个数,个数大于5时,删除文件</span><br><span class="line">        NSArray *array = [fileManager contentsOfDirectoryAtPath:savePath error:nil];</span><br><span class="line">        if (array.count &gt; 4)</span><br><span class="line">        &#123;</span><br><span class="line">            [fileManager removeItemAtPath:savePath error:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码做了一个对缓存文件的简单判断:当缓存文件已经存在的时候,返回标识符YES;缓存文件数量大于4时删除沙盒中的文件</p>
<p>2.下载资源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据链接地址下载音频</span><br><span class="line"></span><br><span class="line"> @param urlString 下载</span><br><span class="line"> @param block     block</span><br><span class="line"> */</span><br><span class="line">- (void)downLoadAudioWithUrlString:(NSString *)urlString</span><br><span class="line">                     downloadBlock:(DownloadAudioFinishBlock)block</span><br><span class="line">&#123;</span><br><span class="line">   // NSURL *soundURL = [NSURL URLWithString:@&quot;http://yinyueshiting.baidu.com/data2/music/122873158/4904681476817261128.mp3?xcode=1276ea4c54f0c8f829676627b54cb918&quot;];</span><br><span class="line">    NSURL *soundURL = [NSURL URLWithString:urlString];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;soundURL:%@&quot;,soundURL);</span><br><span class="line">    </span><br><span class="line">    //将路径拆分成array,然后保存文件名称</span><br><span class="line">    NSArray *seperateArray = [urlString componentsSeparatedByString:@&quot;/&quot;];</span><br><span class="line">    NSString *fileName = seperateArray.lastObject;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    [self audioFilePath:fileName isFileExist:^(BOOL isExist, NSString *savePath)</span><br><span class="line">     &#123;</span><br><span class="line">         //存在文件</span><br><span class="line">         if (isExist)&#123;</span><br><span class="line">             if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //不存在文件</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             //创建网络请求</span><br><span class="line">             NSMutableURLRequest *theRequest = [NSMutableURLRequest requestWithURL:soundURL];</span><br><span class="line">             NSURLSession *session  = [NSURLSession sharedSession];</span><br><span class="line">             </span><br><span class="line">             //根据链接地址下载音频到指定地址</span><br><span class="line">             NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:theRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">                 if (!error) &#123;</span><br><span class="line">                     </span><br><span class="line">                     //注意location是下载后的临时保存路径,需要将它移动到需要保存的位置</span><br><span class="line">                     </span><br><span class="line">                      NSError *saveError;</span><br><span class="line">                      //存储文件</span><br><span class="line">                      NSURL *saveUrl=[NSURL fileURLWithPath:savePath];</span><br><span class="line">                      [[NSFileManager defaultManager] copyItemAtURL:location toURL:saveUrl error:</span><br><span class="line">                       &amp;saveError];</span><br><span class="line">                      if (!saveError) &#123;</span><br><span class="line">                          NSLog(@&quot;save sucess.&quot;);</span><br><span class="line">                          if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">                      &#125;else&#123;</span><br><span class="line">                          NSLog(@&quot;error is :%@&quot;,saveError.localizedDescription);</span><br><span class="line">                          if (block) &#123; block(nil, saveError);&#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                 </span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     NSLog(@&quot;error is :%@&quot;,error.localizedDescription);</span><br><span class="line">                     </span><br><span class="line">                     if ([error.localizedDescription containsString:@&quot; already exists&quot;]) &#123;</span><br><span class="line">                         if (block) &#123; block(savePath, nil);&#125;</span><br><span class="line">                     &#125;else&#123;</span><br><span class="line">                         if (block) &#123; block(nil, error);&#125;</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 </span><br><span class="line">             &#125;];</span><br><span class="line">             [downloadTask resume];</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的url是从百度中找到的音乐下载地址,这里下载音乐和文件是一样的,如果网速太慢,建议找个短点的音乐或者文件之类.此处存放音乐的名称为url截取的一部分. 这样下载文件就完成啦.</p>
<p><a href="https://github.com/XQ0820/PlayAudio" target="_blank" rel="external">上面文章的代码放在这里了:</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前听李笑来老师的讲座,他提到”输出能够有效地推动输入”. 自己写这篇文章略略能感受到这一点,平时读别人的技术博客总是3~5分钟就看过去了,现在想想应该好好感谢所有给自己提供过帮助的博客.有了谷歌,就好像拥有整个宇宙,也希望能通过博客的形式给自己增加一些新鲜的感受,和多一些进步.</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>Hale’s Blog: <a href="http://wuqiuhao.github.io/2016/04/05/iOS%E8%A7%86%E9%A2%91%E3%80%81%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="external">http://wuqiuhao.github.io/2016/04/05/iOS%E8%A7%86%E9%A2%91%E3%80%81%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/</a><br>iOS 音频播放 —— 离线歌曲:<a href="http://www.jianshu.com/p/2fdc6a9142c4" target="_blank" rel="external">http://www.jianshu.com/p/2fdc6a9142c4</a><br>码农人生音频播放系列(大神的文章牛牛哒!):<a href="http://msching.github.io/blog/2014/07/08/audio-in-ios-2/" target="_blank" rel="external">http://msching.github.io/blog/2014/07/08/audio-in-ios-2/</a><br>AVAudioPlayer,AVPlayer以及系统音频:<a href="http://www.jianshu.com/p/e5dbd92871a4" target="_blank" rel="external">http://www.jianshu.com/p/e5dbd92871a4</a><br>iOS音频篇：使用AVPlayer播放网络音乐:<a href="http://www.jianshu.com/p/32b932f44c9b" target="_blank" rel="external">http://www.jianshu.com/p/32b932f44c9b</a><br>iOS Programming 101: Record and Play Audio using AVFoundation Framework:<a href="https://www.appcoda.com/ios-avfoundation-framework-tutorial/" target="_blank" rel="external">https://www.appcoda.com/ios-avfoundation-framework-tutorial/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/24/iOS-播放本地音频/" data-id="cizgqoiko0006uouxc9sca736" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="w-iOS10用户通知框架-User-Notifications-简介-翻译" class="article article-type-w" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/" class="article-date">
  <time datetime="2016-10-17T02:27:24.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/">iOS10用户通知框架(User Notifications)简介(翻译)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>原文链接</strong>: <a href="http://www.appcoda.com/ios10-user-notifications-guide/" target="_blank" rel="external">http://www.appcoda.com/ios10-user-notifications-guide/</a></p>
<p>大家好,欢迎来到iOS10教程的通知指南. 今天,我们将聊一下在iOS10系统中如何实现通知. iOS10的通知API新增和修改了许多特性,包括基于触发器(triggers)的牛掰的请求系统,详细内如会在下文中详细讨论.<br>iOS10通知中最大的改变是<code>UserNotificationsUI</code>的框架,它可以在通知中自定义视图控制器.这就允许创建许多之前系统中完全不可能的很有用的各种通知</p>
<h2 id="简单的用户通知"><a href="#简单的用户通知" class="headerlink" title="简单的用户通知"></a>简单的用户通知</h2><p>我们想要展示的通知并不全是精致且可交互的.因此,接下来开始演示怎么建立一个基本的文本通知.下载<a href="https://github.com/appcoda/NotificationsUI-Demo/raw/master/NotificationsUI.zip" target="_blank" rel="external">初始工程</a>并打开 <code>NotificationsUI.xcodeproj</code>. 看一下整个工程,你会发现什么都没有:我们用 <code>Main.storyboard</code> 结合 <code>ViewController.swift</code> 和 <code>AppDelegate.swift</code> 进行用户交互<br><img src="/img/14764273540293.png" alt=""></p>
<p>打开 <code>Main.storyboard</code> 看一下 <code>ViewController</code> 文件. 今天我们做的这个apple用来提醒用户上网月度AppCoda的文章.它让用户选择需要通知的日期和时间.首先对这个app做一简单的修改:启用通知. 目前选择时间和日期一点用都没有.我们将要更新这个app,使得它在设置时间和日期后在指定时间创建通知.</p>
<p>继续打开 <code>ViewController.swift</code> 让我们开始吧.</p>
<p>当你打开 <code>ViewController.swift</code> 时, 你会发现文件很空. 只有一个在时间选择器选择了新的时间后,会被调用的功能函数<code>datePickerDidSelectNewDate</code>.像前面提到的,现在这个app除了创建通之外什么都没做. 让我们来实现这个功能</p>
<p>在iOS10中创建通知的过程有一点变化.开发人员现在必须创建<em>requests</em>,向iOS请求展示通知.这些请求包括俩部分: <em>triggers</em> 和 <em>content</em> (触发器和内容).一个触发器是一系列发送通知所必须满足的条件.为了在iOS10中显示一个通知,首先从触发器开始.我们使用的基于时间的触发器的类是<code>UNCalendarNotificationTrigger</code>. Apple提供了也提供了其他的类,例如 <code>UNLocationNotificationTrigger</code> (当用户到达指定地点时触发通知)</p>
<p>像上面声明的: 在iOS中展示通知的第一步是创建一个触发器.现在,让我们继续并且创建一个触发器.</p>
<p>打开 <code>AppDelegate.swift</code>, 确保已经导入了 <code>UserNotification</code>框架, 所有通知相关的API都在这个框架里面:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import UserNotifications</span><br></pre></td></tr></table></figure>
<p>接下来,添加函数<code>scheduleNotification(at date: Date)</code>.名如其义,这个函数负责在提供的日期内定制一个通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func scheduleNotification(at date: Date) &#123;</span><br><span class="line">    let calendar = Calendar(identifier: .gregorian)</span><br><span class="line">    let components = calendar.dateComponents(in: .current, from: date)</span><br><span class="line">    let newComponents = DateComponents(calendar: calendar, timeZone: .current, month: components.month, day: components.day, hour: components.hour, minute: components.minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中, 使用 <code>Gregorian</code> 日历将提供的日期分成几个组件.日期与组件不在这个教程的范围内,但需要知道一个日期由组件组成.单独展示日期的组件,例如小时,分钟,秒等.刚才的代码将时间拆分成组件并保存在 <code>components</code> 常量中.这样做是因为执行 <code>UNCalendarNotificationTrigger</code> 需要日期组件而不是日期. 然而, <code>UNCalendarNotificationTrigger</code>比较诡异的一点是直接从日期中取出完整的组件并不能使用, 而需要从已存在的实例中读取信息创建自己的 <code>DateComponents</code> 实例. 第三行代码就是做这个的:它只是从 <code>date</code> 中获取了相关信息创建了新的 <code>DateComponents</code> 实例.</p>
<p>现在有了 <code>date</code> 的组件, 继续啊创建日历通知触发器. 像在iOS中的其他东西一样, <em>Apple</em>使这个创建过程相当简单. 只需要将下面的代码加入函数中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let trigger = UNCalendarNotificationTrigger(dateMatching: newComponents, repeats: false)</span><br></pre></td></tr></table></figure></p>
<p>跟预想的一样,这行代码用时间组件创建了新的 <code>UNCalendarNotificationTrigger</code>. 因为只需要通知出现一次,将<code>repeats</code>设置为 <code>false</code>.</p>
<p>现在已经创建完触发器,接下来的就是创建需要在通知中展示的 <em>content</em>. 这可以通过 <code>UNMutableNotificationContent</code> 类完成. 将下面几行代码放在 <code>trigger</code> 变量的下面创建通知内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let content = UNMutableNotificationContent()</span><br><span class="line">content.title = &quot;Tutorial Reminder&quot;</span><br><span class="line">content.body = &quot;Just a reminder to read your tutorial over at appcoda.com!&quot;</span><br><span class="line">content.sound = UNNotificationSound.default()</span><br></pre></td></tr></table></figure>
<p>这些代码就能理解其含义:我们创建了一个新的 <code>UNMutableNotificationContent</code> 实例, 然后设置它的标题, 内容, 声音.</p>
<p>看起来好像我们已经准备好展示第一个通知了. 然而,还剩俩步需要完成:1.创建通知<em>request</em>, 2.将它提供给系统,告诉iOS展示通知.</p>
<p>为了创建通知请求,用相关的内容和触发器初始化一个 <code>UNNotificationRequest</code> 对象.还需要一个唯一标识码用来识别这个通知请求. 在 <code>scheduleNotification</code>函数中插入下面这行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let request = UNNotificationRequest(identifier: &quot;textNotification&quot;, content: content, trigger: trigger)</span><br></pre></td></tr></table></figure></p>
<p>很简单,对么?创建请求需要3个参数:</p>
<ul>
<li><code>identifier</code>: 这是我们请求的唯一标识.你很快就会看到,这个标识能用来取消通知请求.</li>
<li><code>content</code>: 这是之前创建的通知内容</li>
<li><code>trigger</code>: 这个触发器用来触发通知.当满足触发条件后,iOS将会展示这个通知</li>
</ul>
<p>好了,现在要做的最后一件事是将请求添加进管理整个app所有通知的通知中心.通知中心会根据合适的时间触发通知.</p>
<p>将通知请求加入通知中心之前,最好先将已经存在的通知请求移除, 这样能够避免重复通知. 将下面的代码段加入函数中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter.current().removeAllPendingNotificationRequests()</span><br><span class="line">UNUserNotificationCenter.current().add(request) &#123;(error) in</span><br><span class="line">    if let error = error &#123;</span><br><span class="line">        print(&quot;Uh oh! We had an error: \(error)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码得到通知中心的单例并调用 <code>removeAllPendingNotificationRequests</code> 方法移除所有挂起的通知请求.然后将请求加入通知中心.这个方法也在函数完成后也会调用.在我们实现中,这个控制器用来打印错误. 在继续操作之前, 确保 <code>scheduleNotification</code> 函数如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func scheduleNotification(at date: Date) &#123;</span><br><span class="line">    let calendar = Calendar(identifier: .gregorian)</span><br><span class="line">    let components = calendar.dateComponents(in: .current, from: date)</span><br><span class="line">    let newComponents = DateComponents(calendar: calendar, timeZone: .current, month: components.month, day: components.day, hour: components.hour, minute: components.minute)</span><br><span class="line">    </span><br><span class="line">    let trigger = UNCalendarNotificationTrigger(dateMatching: newComponents, repeats: false)</span><br><span class="line">    </span><br><span class="line">    let content = UNMutableNotificationContent()</span><br><span class="line">    content.title = &quot;Tutorial Reminder&quot;</span><br><span class="line">    content.body = &quot;Just a reminder to read your tutorial over at appcoda.com!&quot;</span><br><span class="line">    content.sound = UNNotificationSound.default()</span><br><span class="line">    </span><br><span class="line">    let request = UNNotificationRequest(identifier: &quot;textNotification&quot;, content: content, trigger: trigger)</span><br><span class="line">    </span><br><span class="line">    UNUserNotificationCenter.current().removeAllPendingNotificationRequests()</span><br><span class="line">    UNUserNotificationCenter.current().add(request) &#123;(error) in</span><br><span class="line">        if let error = error &#123;</span><br><span class="line">            print(&quot;Uh oh! We had an error: \(error)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果代码和上面的一样,准备出发吧! 现在我们需要做的是在 <code>ViewController.swift</code>中配置当用户选择时间后调用<code>scheduleNotification(date:)</code> .在 <code>ViewController.swift</code>中,将下面的代码加入<code>datePickerDidSelectNewDate</code> 方法中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let selectedDate = sender.date</span><br><span class="line">let delegate = UIApplication.shared.delegate as? AppDelegate</span><br><span class="line">delegate?.scheduleNotification(at: selectedDate)</span><br></pre></td></tr></table></figure></p>
<p>上面的代码获取到了当前应用正在使用的的<code>AppDelegate</code>实例并用之前写的的函数定制通知.快来试试吧!运行app并选择未来的时间.等到设备时间到选择时间后看看发生了什么!</p>
<p>呃,通知没出现,但是为什么呢?</p>
<p>这有一些通知没出现的原因.</p>
<p>首先,苹果致力于在iOS上保持一个完美的用户体验,体验的一部分是给用户提供从app内接受通知的控制权限.用户还没有授权展示通知,这就是为什么通知没有展现的原因.</p>
<p>让我们修复这个问题.将下面的代码加入 <code>AppDelegate.swift</code>的方法中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool &#123;</span><br><span class="line">    </span><br><span class="line">    UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound]) &#123;(accepted, error) in</span><br><span class="line">        if !accepted &#123;</span><br><span class="line">            print(&quot;Notification access denied.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们调用通知中心的<code>requestAuthorization</code>方法来获得用户使用通知的许可.我们也请求展示<br>告警和声音的能力.</p>
<p>现在重新运行app.当app加载后,你会看见授权请求.确保你同意,然后app能够向设备发送通知.</p>
<p>另一件你需要记住的是,这个通知不会再app内展示.因此,一旦你设置了日期,确保你返回主屏幕并锁屏.<br>如果所有步骤都准确无误,通知就会出现啦!<br><img src="/img/14764376688190.jpg" alt=""></p>
<p>看见没? 向iOS用户发送通知没那么难, 只需要先执行一些预提示的步骤,例如请求通知权限.现在已经发送了简单的文本,让我们再加一张图片!</p>
<h2 id="在通知中附加图片"><a href="#在通知中附加图片" class="headerlink" title="在通知中附加图片"></a>在通知中附加图片</h2><p>这个通知现在是基于文本.这没啥新鲜的! 让我们探索一下其他的特征,类似于在通知中展示图片.</p>
<p>在初始工程中,我已经绑定了一张图片:名为 <code>logo.png</code> .如果你没看见,可能是因为它隐藏在<code>NotificationsUI</code>组中了. 无论怎样,这张图片在初始工程中. 让我们来看一下怎么将它展示在通知中.</p>
<p><code>UserNotification</code> 框架为开发者提供了<code>UNNotificationAttachment</code>类,用来在通知中添加附件.附件可以是录音,图片和音频.他也支持许多文件格式. 更详细的信息可见看<a href="https://developer.apple.com/reference/usernotifications/unnotificationattachment" target="_blank" rel="external"> Apple Developer Website</a></p>
<p>建立一个附件相当简单,像<code>UserNotifications.framework</code> 中的大多数任务一样. 我们只需要初始化<code>UNNotificationAttachment</code> 实例并把它加到通知内容中.更新 <code>scheduleNotification</code>方法并将下面的代码块插入在<code>request</code>变量前面.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if let path = Bundle.main.path(forResource: &quot;logo&quot;, ofType: &quot;png&quot;) &#123;</span><br><span class="line">    let url = URL(fileURLWithPath: path)</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        let attachment = try UNNotificationAttachment(identifier: &quot;logo&quot;, url: url, options: nil)</span><br><span class="line">        content.attachments = [attachment]</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        print(&quot;The attachment was not loaded.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码加载了logo图片的地址,转化为<code>URL</code>,然后用图片初始化附件.<code>UNNotificationAttachment</code>的初始化被标记为投掷条件, 所以需要一个<code>catch</code>block 解决错误.一旦创建好附件,将它加入<code>content</code>中.重新测试app.一旦应用加载,选择一个日期等待通知出现.</p>
<p><img src="/img/14764388175933.png" alt=""><br>天哪!快看,我们发送了一个带图片的通知.这是在iOS10中首先提到的新特性.这特别酷,但我想如果能加一个 “稍后提示”按钮允许用户暂时忽略这个提示会更好.</p>
<p>现在就做这个吧.</p>
<h2 id="用通知的方法添加一个提示"><a href="#用通知的方法添加一个提示" class="headerlink" title="用通知的方法添加一个提示"></a>用通知的方法添加一个提示</h2><p>按照API中设定的方式,在通知中加入一个功能有点复杂.然而,没什么是不能解决的.为了在通知中加入一个功能,需要使用<code>UNNotificationAction</code>和<code>UNNotificationCategory</code>.</p>
<p>首先,需要为功能定义一个类别<em>categories</em>. 只定义一个类别和一个功能.将下面几行代码插入<code>application(_:didFinishLaunchingWithOptions:)</code>方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let action = UNNotificationAction(identifier: &quot;remindLater&quot;, title: &quot;Remind me later&quot;, options: [])</span><br><span class="line">let category = UNNotificationCategory(identifier: &quot;myCategory&quot;, actions: [action], intentIdentifiers: [], options: [])</span><br><span class="line">UNUserNotificationCenter.current().setNotificationCategories([category])</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了一个动作一个类别,并用<code>UNNotificationCategory</code>登记这个类别.</p>
<p>可能,你会好奇为什么会存在类别. 他们用于不同的目的.将一个类别想象为一组功能,一旦创建,就能够在<code>UNNotificationContent</code> 中为通知添加一个类别, 这个类别中包含的所有功能都会展示在这个通知中</p>
<p>在这个demo中,类别里面只有一个功能; 但如果我们许多功能,将它们赋值给类会使他们都得到使用.这就是为什么苹果的工程师提供了<code>UNNotificationCategory</code>来管理通知的功能.</p>
<p>现在创建了一个功能一个类别并且登记了这个类别,使用它.更改创建<code>content</code>的这部分代码然后加入下面的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content.categoryIdentifier = &quot;myCategory&quot;</span><br></pre></td></tr></table></figure></p>
<p>这是告诉系统我们想在新的通知中使用<code>myCategory</code>.现在,编译并重新运行app看看发生了什么:<br><img src="/img/14764404214267.png" alt=""><br>太帅了! 我们的通知现在有了一个可爱的按钮.但是如果你点击这个按钮,它只是让通知消失了.剩下需要做的是编写相应这个动作的代码.</p>
<p><code>UNUserNotificationCenterDelegate</code>协议定义了通知回调的方法.所以,为了响应这个动作,让我们扩展<code>AppDelegate</code>来实现<code>UNUserNotificationCenterDelegate</code>这个协议.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension AppDelegate: UNUserNotificationCenterDelegate &#123;</span><br><span class="line">    func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>userNotificationCenter(_:didReceive:withCompletionHandler:)</code>方法会在用户选择一个动作后调用.你能通过已给的<code>UNNotificationResponse</code>的<code>actionIdentifier</code>获得用户选择的动作.让我们完成这个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123;</span><br><span class="line"> </span><br><span class="line">    if response.actionIdentifier == &quot;remindLater&quot; &#123;</span><br><span class="line">        let newDate = Date(timeInterval: 900, since: Date())</span><br><span class="line">        scheduleNotification(at: newDate)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码定制了一个当前时间之后的900秒(60s * 15 min)的新通知.最后,在 <code>scheduleNotification(at:)</code>方法中设置默认的通知中心的代理为<code>AppDelegate</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNUserNotificationCenter.current().delegate = self</span><br></pre></td></tr></table></figure>
<p>现在重新运行这个app并定制一个通知来测试它们.当通知出现后,点击<code>Remind me later</code>按钮.<br>你会在15分钟之后收到另一个通知.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望你喜欢这个关于用户通知框架的指导教程.在第二部分,我们会更深入的讨论通知并学习在通知中植入自定义的视图控制器.</p>
<p>你可以在Github上下载这份教程的<a href="https://github.com/appcoda/NotificationsUI-Demo" target="_blank" rel="external">demo工程</a></p>
<p><strong>声明</strong>: </p>
<ul>
<li>原英文文章来源于appcoda,本人仅作个人学习使用;若侵犯了原作者权益,立即删除</li>
<li>本人英语水平有限,文章中若有翻译上的错误,还请指正(<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#58;&#x78;&#x69;&#97;&#113;&#105;&#x6e;&#x67;&#48;&#56;&#x32;&#x30;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#x78;&#x69;&#97;&#113;&#105;&#x6e;&#x67;&#48;&#56;&#x32;&#x30;&#64;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a>)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/17/iOS10用户通知框架-User-Notifications-简介-翻译/" data-id="cizgqoikl0004uoux0kcb1kc4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-在Xcode7中使用Swift进行单元测试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/21/在Xcode7中使用Swift进行单元测试/" class="article-date">
  <time datetime="2016-09-21T02:16:17.000Z" itemprop="datePublished">2016-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/21/在Xcode7中使用Swift进行单元测试/">在Xcode7中使用Swift进行单元测试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS 程序员经常需要debug自己的app,除非你是那种疯狂的程序大神,不然一定体会过几个小时几个小时找Bug最后却发现只是变量声明有误时候那种绝望的心情.比这更糟糕的是,几个小时也没找到Bug的原因. 无论你是程序新人还是开发过许多app的程序员,规范的编写单元测试能够使代码更可靠,安全且容易检查.</p>
<p>幸运的是,Xcode7和Swift支持单元测试.虽然写了单元测试并不代表程序没Bug, 它仍然是检查代码片段按预期执行并使debug容易些的相当有效的方法.</p>
<p>如名字那样,在单元测试中,会对指定的代码片段建立小的有针对性的测试函数,以确保每段代码都可以通过测试.如果测试通过,在函数旁边会出现绿色的标志.如果测试没有通过,无论失败原因是什么,Xcode都会将代码标记为失败.这表示你需要在代码中查找产生错误的原因</p>
<h2 id="Demo概览"><a href="#Demo概览" class="headerlink" title="Demo概览"></a>Demo概览</h2><p>首先,在<a href="http://www.appcoda.com/unit-testing-swift/" target="_blank" rel="external">这里</a>下载我已经创建好的工程,这是个简单的用数值和百分比进行百分比计算的应用.(exp:10% * 80 = 8)</p>
<p>这个百分比计算器相当简单.你主要看ViewController.swift这个文件, 文件中的代码注释的很通俗易懂.</p>
<p>工程中一共有5对关联关系:每一个关系对应界面上的一个UI元素,除标题外,还有俩个IBActions对应俩个Slider,每个IBAction的名称准确解释了这个方法需要执行的动作.当俩个滑块中的任一个改变时,百分比和数值跟着一起改变</p>
<p>此外,还有俩个简单的函数 <code>updateLabels()</code> 和 <code>percentage()</code> 用来执行你想要完成的动作:第一个函数更新滑块滑动时展示的数值,第二个函数传入俩个浮点型数值并返回百分比计算结果.</p>
<p>在模拟器中运行app. 刚开始时候,一切正常.但只要你开始更新数值,就会发现计算结果不对.为了找到这个Bug,我们可以将代码分成几个单元并分开测试以检查各部分是否按照预期执行. 这样做并不会解决Bug, 但能够缩小你找Bug的范围.</p>
<p><img src="/img/unit-test-demo-app.png" alt="unit-test-demo-app"></p>
<p>创建工程时,我选了默认包含测试文件.(如果你想手动添加文件,在iOS资源文件中依次点击 File &gt; New &gt; File &gt; Unit Test Case).此处,测试文件已经由Xcode建好,可以在 导航器的<code>PercentageCalculatorTests</code> 文件夹中找到<br><img src="/img/xcode-unit-test-option.png" alt="xcode-unit-test-option"></p>
<p>在<code>PercentageCalculatorTests.swift</code>文件中,类 <code>PercentageCalculatorTests</code> 里面已经创建了4个方法. 其中俩个是示例,可以删除(可以通过关键字<code>test</code>找到,并且在方法的序号列左侧有个方块形icon,名称以 <code>Example</code> 结尾).另俩个函数: <code>setUp()</code> 和 <code>tearDown()</code> 是专门用于测试的,在测试方法执行前后会依次调用.</p>
<h2 id="开始编写单元测试"><a href="#开始编写单元测试" class="headerlink" title="开始编写单元测试"></a>开始编写单元测试</h2><p>现在,将要开始写你的第一个单元测试!这个教程中,只测试类 <code>ViewController</code> . 我们需要在 <code>PercentageCalculatorTests</code> 添加一个实例.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class PercentageCalculatorTests: XCTestCase &#123;</span><br><span class="line">    var vc: ViewController!</span><br><span class="line">    </span><br><span class="line">    override func setUp() &#123;</span><br><span class="line">        super.setUp()</span><br><span class="line">        // Put setup code here. This method is called before the invocation of  each test method in the class.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func tearDown() &#123;</span><br><span class="line">        // Put teardown code here. This method is called after the invocation of each test method in the class.</span><br><span class="line">        super.tearDown()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 <code>PercentageCalculatorTests</code> 继承于 <code>XCTestCase</code>. 它包含了 <code>XCTest</code>框架. 每个<code>XCTestCase</code> 子类的实例负责测试工程中指定的一部分,例如一个特殊的特点.</p>
<p>因为 <code>setup</code> 在所有测试方法之前调用, 在<code>setup</code>方法中初始化 <code>vc</code> , 这样可以在每个测试方法中获得一个新的 <code>ViewController</code> 实例. 像下面的代码一样更新 <code>setUp</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override func setUp() &#123;</span><br><span class="line">    super.setUp()</span><br><span class="line"> </span><br><span class="line">    let storyboard = UIStoryboard(name: &quot;Main&quot;, bundle: NSBundle.mainBundle())</span><br><span class="line">    vc = storyboard.instantiateInitialViewController() as! ViewController</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住所有的测试方法都以关键字 <code>test</code> 开头,否则Xcode不识别. 添加一个新方法 <code>testPercentageCalculator</code> 用来确认 <code>ViewController</code> 中的<code>percentage()</code>方法是否正常运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单元测试时要检查某一大块代码是否正常运行. 这一大块代码通常只需要几行典型的代码来测试,你只测试一个方法或函数. 单元测试通过给一部分代码提供一个入参,用这个执行代码,然后检查返回参数是不是与我们预期的相符合<br><img src="/img/Example.png" alt="Example"></p>
<p>比较我们预期结果是否正确这部分由 <code>XCTAssert</code>函数完成. 最简单的<code>XCTAssert</code> 函数为<code>XCTAssert(expression: BooleanType)</code>,需要传入BOOL表达式(exp: <code>5 &gt; 3</code>, <code>8.90 == 8.90</code> or <code>true</code>),函数返回真或假使得测试通过.</p>
<p>快来试试吧!首先,在方法<code>testPercentageCalculator()</code>中加入下面这行.然后,将鼠标移动到方法名左边的菱形块图标处,鼠标来回移动,icon变成一个可运行的icon然后点击开始测试.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">        XCTAssert(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果运行顺利,测试通过,方法旁边出现一个绿色的对号.<br><img src="/img/unit-test-green-mark.png" alt="unit-test-green-mark"></p>
<h2 id="检查百分比计算结果"><a href="#检查百分比计算结果" class="headerlink" title="检查百分比计算结果"></a>检查百分比计算结果</h2><p>现在开始动真格了:测试<code>percentage()</code>方法. 通过 <code>vc</code>属性调用这个方法, <code>vc</code>是<code>ViewController</code> 的一个实例. 传俩个浮点值 50 和 50 ,用静态值<code>p</code>保存结果. 在这里, <code>p</code>应该等于25 (50 * 50% = 25),检查这个用例 <code>XCTAssert(p == 25)</code>并执行测试方法. 用下面的代码替换<code>testPercentageCalculator()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func testPercentageCalculator() &#123;</span><br><span class="line">        // Should be 25</span><br><span class="line">        let p = vc.percentage(50, 50)</span><br><span class="line">        XCTAssert(p == 25)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试通过,意味着<code>ViewController</code> 的 函数 <code>percentage()</code>正常执行, 需要在其他地方找    bug原因. 可能在 <code>updateLabels()</code> 方法中</p>
<h2 id="检查Label"><a href="#检查Label" class="headerlink" title="检查Label"></a>检查Label</h2><p>添加一个新的测试方法 <code>testLabelValuesShowedProperly()</code> 用来检查Label上的内容是否正确.然后从ViewController中调用方法 <code>updateLabels()</code>,这次, 我们检查每个Label上的text属性和我们想要展示的东西是否相符.</p>
<p>记得你给 <code>XCTAssert</code>函数一个新的参数:字符串消息. 这样很方便,因为我们有多个(调用<code>XCTAssert</code>三次)需要完成检测的值. 如果测试不成功,这个消息会告诉我们到底哪里有问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func testLabelValuesShowedProperly() &#123;</span><br><span class="line">        vc.updateLabels(Float(80.0), Float(50.0), Float(40.0))</span><br><span class="line">        </span><br><span class="line">        // The labels should now display 80, 50 and 40</span><br><span class="line">        XCTAssert(vc.numberLabel.text == &quot;80.0&quot;, &quot;numberLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.percentageLabel.text == &quot;50.0%&quot;, &quot;percentageLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.resultLabel.text == &quot;40.0&quot;, &quot;resultLabel doesn&apos;t show the right text&quot;)</span><br></pre></td></tr></table></figure>
<p>当你要执行这个方法时,你会得到<code>numberLabel</code>,<code>percentageLabel</code>,<code>resultsLabel</code>为<code>nil</code>的错误信息.这怎么可能?</p>
<p>这是因为我在Storyboard文件中创建的Label,因此他们仅在视图加载时调用一次.但是单元测试中<code>loadView()</code>方法永不执行, 所以Label没有被创建他们都是<code>nil</code>. 这个问题有一个解决办法是调用<code>vc.loadView()</code> ,但苹果在官方文档中不建议这样做,因为视图已经加载后再加载一遍可能会引起内存泄漏.</p>
<p>你应该获得<code>vc</code>的属性<code>view</code>,他会按顺序触发需要的方法,而不仅仅是<code>loadView()</code>.在<code>testLabelValuesShowedProperly()</code>中更新代码.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func testLabelValuesShowedProperly() &#123;</span><br><span class="line">        let _ = vc.view</span><br><span class="line">        vc.updateLabels(Float(80.0), Float(50.0), Float(40.0))</span><br><span class="line">        </span><br><span class="line">        // The labels should now display 80, 50 and 40</span><br><span class="line">        XCTAssert(vc.numberLabel.text == &quot;80.0&quot;, &quot;numberLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.percentageLabel.text == &quot;50.0%&quot;, &quot;percentageLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">        XCTAssert(vc.resultLabel.text == &quot;40.0&quot;, &quot;resultLabel doesn&apos;t show the right text&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用下滑线(_)默认一个常量名称,因为我们并不需要这个view而且也不会用到它.它只是告诉编译器”假装获得了这个视图并触发方法”</p>
<p>执行这个测试(如果你想执行测试类中的所有方法,你可以点击<code>class PercentageCalculatorTests</code>旁边的方形)<br><img src="/img/unit-test-demo-fail.png" alt="unit-test-demo-fai"></p>
<h2 id="修复Bug"><a href="#修复Bug" class="headerlink" title="修复Bug"></a>修复Bug</h2><p>如你所见,测试失败!具体的错误信息可以帮助我们确定可能引起Bug的原因. 结果告诉我们resultsLabel没有返回正确的text.让我们进到ViewController检查这些Label的是怎么被赋值的.在深入检查<code>ViewController.swift</code> 中的<code>updateLabels()</code>代码后,可以发现因为Bug的原因:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resultLabel.text = &quot;\(rV + 10)&quot;</span><br></pre></td></tr></table></figure>
<p>应该为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.resultLabel.text = &quot;\(rV)&quot;</span><br></pre></td></tr></table></figure>
<p>更新代码然后再次测试.万事顺利!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这个教程中,学习了Xcode中的单元测试以及单元测试怎么帮助你在代码中找到Bug.除了减少Bug,单元测试能用来性能测试和异步测试. 其他吸引人的部分是UI测试,能通过记录动作在app中还原真实场景的表现.如果这听起来很有意思,你真该好好看看<a href="https://developer.apple.com/videos/play/wwdc2015-406/" target="_blank" rel="external">这部分关于UI测试的视频</a></p>
<p>完整代码,可以在<a href="https://github.com/appcoda/SwiftUnitTestDemo" target="_blank" rel="external">这里下载</a></p>
<p><strong>原文链接</strong>: <a href="http://www.appcoda.com/unit-testing-swift/" target="_blank" rel="external">http://www.appcoda.com/unit-testing-swift/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/21/在Xcode7中使用Swift进行单元测试/" data-id="cizgqoili000iuoux5vxqlxsg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HealthKit-使用笔记-一" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/HealthKit-使用笔记-一/" class="article-date">
  <time datetime="2016-08-05T09:18:21.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/HealthKit-使用笔记-一/">HealthKit 使用笔记(一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要用HealthKit"><a href="#为什么要用HealthKit" class="headerlink" title="为什么要用HealthKit"></a>为什么要用HealthKit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  公司在做一款健康类的app, 要将各类第三方设备数据统计起来,而运动作为唯一一个手机本身就可以测量计步的功能模块,要好好利用起来.由于产品人员本身没有对手机计步功能的数据统计做出具体的逻辑要求, 以至于自己开发过程中分别经历了几个阶段</span><br><span class="line">1. 起初为了实现实时计步功能,自己选用了CoreMotion框架,因为CoreMotion框架的实时性更好,且读取数据更简单</span><br><span class="line">2. 一段时间后,领导们觉得既然用户给了读取数据的权限,那么需要将用户的历史数据保存起来,以备日后数据分析 ??, 所以自己接入了HealthKit框架用来保存历史数据,同时使用CoreMotion实时计步.</span><br><span class="line">3. 再后来, 服务器同学觉得 实时计步然后实时向服务器上传的方式不好, 并且还出现了一些其他小问题,所以我又将CoreMotion框架删除,并使用HealthKit统计当日运动步数数据??. 当时的微信运动的数据应该也只取了数据源为本机的数据, 因此领导要求我们的app需要保证和微信一样只取数据源为&quot;手机&quot;的数据??</span><br><span class="line">4. 又后来, app需要兼容iOS10, 与此同时,领导发现&quot;咦, 怎么微信数据和我们数据不一致?!blablababalala&quot;. 于是只好,又研究HealthKit??, 宝宝不开心</span><br></pre></td></tr></table></figure>
<h2 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h2><h3 id="CoreMotion"><a href="#CoreMotion" class="headerlink" title="CoreMotion"></a>CoreMotion</h3><ul>
<li>判断当前手机是否支持计步(是否包含M7以上协处理器, iPhone5s以上机型支持)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//实时从系统中读取数据 M7处理器功能是不是可用</span><br><span class="line">if (![CMPedometer isStepCountingAvailable])</span><br><span class="line"> &#123;</span><br><span class="line">    return ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CMPedometer *pedometer = [[CMPedometer alloc] init];</span><br><span class="line">NSDate *startDate = ...;</span><br><span class="line">NSDate *toDate = [NSDate date];</span><br><span class="line"> [pedometer queryPedometerDataFromDate:startDate</span><br><span class="line">                                       toDate:endDate</span><br><span class="line">                                  withHandler:</span><br><span class="line">    ^(CMPedometerData *pedometerData, NSError *error) </span><br><span class="line">&#123;</span><br><span class="line">  //do whatever you want</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实时更新数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMPedometer *pedometer = [[CMPedometer alloc] init];</span><br><span class="line"> [pedometer startPedometerUpdatesFromDate:fromDate withHandler:^(CMPedometerData *  _Nullable pedometerData, NSError * _Nullable error) </span><br><span class="line"> &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HealthKit"><a href="#HealthKit" class="headerlink" title="HealthKit"></a>HealthKit</h3><ul>
<li>以下的所有 <code>self.healthStore</code> 通过 <code>getter</code> 方法获得</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (HKHealthStore *)healthStore</span><br><span class="line">&#123;</span><br><span class="line">    if (!_healthStore) &#123;</span><br><span class="line">        _healthStore = [[HKHealthStore alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _healthStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断当前手机是否支持HealthKit框架</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isHealthDataAvailable</span><br><span class="line">&#123;</span><br><span class="line">    return [HKHealthStore isHealthDataAvailable];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得使用用户数据的权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**获得使用授权 */</span><br><span class="line">- (void)authorizateHealthKit:(void(^)(BOOL isAuthorizateSucess))resultBlock</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW,</span><br><span class="line">                                 (int64_t)(1.0 * NSEC_PER_SEC)),</span><br><span class="line">                   dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                       NSSet *readObjectTypes =</span><br><span class="line">                       //步数</span><br><span class="line">                       [NSSet setWithObjects:</span><br><span class="line">                        [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount],</span><br><span class="line">                        //血糖</span><br><span class="line">                        [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBloodGlucose],</span><br><span class="line">                        //心脏收缩压</span><br><span class="line">                        [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBloodPressureSystolic],</span><br><span class="line">                        //心脏舒张压</span><br><span class="line">                        [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierBloodPressureDiastolic],</span><br><span class="line">                                                 nil];</span><br><span class="line">                       </span><br><span class="line">                       [self.healthStore</span><br><span class="line">                        requestAuthorizationToShareTypes:nil</span><br><span class="line">                        readTypes:readObjectTypes</span><br><span class="line">                        completion:^(BOOL success, NSError * _Nullable error)</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (resultBlock) &#123;</span><br><span class="line">                                resultBlock(success);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得日统计数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/** 获得当日展示数据*/</span><br><span class="line">- (void)fetchHealthMotionDailyData:(void(^)(NSDictionary *resultDictionary))resultBlock</span><br><span class="line">&#123;</span><br><span class="line">    /**从HealthKit中读取数据*/</span><br><span class="line">    [self authorizateHealthKit:^(BOOL isAuthorizateSucess) &#123;</span><br><span class="line">        </span><br><span class="line">        if (!isAuthorizateSucess) &#123;</span><br><span class="line">            //授权失败,提示用户</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        __block NSMutableDictionary *tempDictionary = [NSMutableDictionary dictionaryWithCapacity:1];</span><br><span class="line">        [self fetchSampleDataResultBlock:^(NSDictionary *queryResultDict) &#123;</span><br><span class="line">            int stepValue;</span><br><span class="line">            if ([queryResultDict.allKeys containsObject:@&quot;sampleStepCount&quot;]) &#123;</span><br><span class="line">            //此处即为所得到的运动步数</span><br><span class="line">                stepValue = ((NSNumber *)queryResultDict[@&quot;sampleStepCount&quot;]).intValue;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                stepValue = 0;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)fetchSampleDataResultBlock:(void(^)(NSDictionary *queryResultDict))resultBlock</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableDictionary *tempDict = @&#123;&#125;.mutableCopy;</span><br><span class="line"></span><br><span class="line">    NSDateFormatter *formatter = [[NSDateFormatter alloc]init];</span><br><span class="line">    [formatter setDateFormat:@&quot;yyyy-MM-dd&quot;];</span><br><span class="line">    NSString *today = [formatter stringFromDate:[NSDate date]];</span><br><span class="line">    NSDate *fromDate = [MMUtils stringToDate:today isStart:YES];</span><br><span class="line">    </span><br><span class="line">    HKSampleType *sampleType = [HKSampleType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];</span><br><span class="line">    __block double totalStepCount = 0;//总步行数</span><br><span class="line"></span><br><span class="line">    //TODO:----0805</span><br><span class="line">    //获取当日数据有俩种方法</span><br><span class="line">    if (0) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;</span><br><span class="line">        //1.第一种方法为 按时间点数据累加,但当数据源有若干个时,累加的数据会变成所有数据源数据之和</span><br><span class="line">        [self executeQueryQuantityType:sampleType startDate:fromDate endDate:[NSDate date] callBackResultBlock:^(NSArray * _Nullable results, NSError *error) &#123;</span><br><span class="line">            </span><br><span class="line">            for (HKQuantitySample *sample in results)</span><br><span class="line">            &#123;</span><br><span class="line">                //根据数据源累加数据</span><br><span class="line">                if ([sample.source.name isEqualToString:[UIDevice currentDevice].name])</span><br><span class="line">                &#123;</span><br><span class="line">                    double stepCount = [sample.quantity doubleValueForUnit:[HKUnit countUnit]];</span><br><span class="line">                    </span><br><span class="line">                    totalStepCount += stepCount;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            [tempDict setObject:@(totalStepCount) forKey:kTotalSampleStepCountKey];</span><br><span class="line">            </span><br><span class="line">            if (resultBlock) &#123;</span><br><span class="line">                resultBlock(tempDict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"> #pragma clang diagnostic pop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.第二种方法为获取当日数据的统计数据,使用这种方式,可以在有若干数据源时,获得与&quot;健康app&quot;相对应的统计数据</span><br><span class="line">    HKQuantityType *quantityType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];</span><br><span class="line"></span><br><span class="line">    [self executeQueryQuantityType:quantityType startDate:fromDate endDate:[NSDate date] callBackResultBlock:^(NSArray * _Nullable results, NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">        HKStatistics *result = results[0];</span><br><span class="line">        HKQuantity *sum = [result sumQuantity];//此处即为请求当日已经统计过的数据</span><br><span class="line">        double stepCount = [sum doubleValueForUnit:[HKUnit countUnit]];</span><br><span class="line">        [tempDict setObject:@(stepCount) forKey:kTotalSampleStepCountKey];</span><br><span class="line">        if (resultBlock) &#123;</span><br><span class="line">            resultBlock(tempDict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//数据点查询</span><br><span class="line"></span><br><span class="line">- (void)executeQueryQuantityType:(HKSampleType *)quantityType</span><br><span class="line">                       startDate:(NSDate *)startDate</span><br><span class="line">                         endDate:(NSDate *)endDate</span><br><span class="line">             callBackResultBlock:(void(^)(NSArray * __nullable results, NSError *error))resultBlock</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    HKQuantityType *stepType = [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];</span><br><span class="line">    NSPredicate *predicate = [HKQuery predicateForSamplesWithStartDate:startDate endDate:endDate options:HKQueryOptionStrictStartDate];</span><br><span class="line">    NSSortDescriptor *sortDescriptor = [NSSortDescriptor sortDescriptorWithKey:HKSampleSortIdentifierStartDate ascending:YES];</span><br><span class="line">    </span><br><span class="line">    //TODO:----0805 要求查询统计数据</span><br><span class="line"></span><br><span class="line">    if (0) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunreachable-code&quot;</span><br><span class="line">//按照查询条件,返回满足时间段内的所有数据</span><br><span class="line">        HKSampleQuery *sampleQuery = [[HKSampleQuery alloc] initWithSampleType:stepType</span><br><span class="line">                                                                     predicate:predicate</span><br><span class="line">                                                                         limit:HKObjectQueryNoLimit</span><br><span class="line">                                                               sortDescriptors:@[sortDescriptor]</span><br><span class="line">                                                                resultsHandler:^(HKSampleQuery *query, NSArray *results, NSError *error)</span><br><span class="line">                                      &#123;</span><br><span class="line">                                          if (resultBlock) &#123;</span><br><span class="line">                                              resultBlock(results, error);</span><br><span class="line">                                          &#125;</span><br><span class="line">                                          </span><br><span class="line">                                      &#125;];</span><br><span class="line">        [self.healthStore executeQuery:sampleQuery];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查询当天数据的统计数据</span><br><span class="line">    //查询数据的时间间隔</span><br><span class="line">    NSDateComponents *intervalCompents = [[NSDateComponents alloc]init];</span><br><span class="line">    intervalCompents.day = 1;</span><br><span class="line">    </span><br><span class="line">    //查询数据的开始时间(锚点 anchordate)</span><br><span class="line">    //1.获取日历</span><br><span class="line">    NSCalendar *calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">    </span><br><span class="line">    //2.当前时间组件</span><br><span class="line">    NSDateComponents *currentCompents = [calendar components:NSCalendarUnitSecond|NSCalendarUnitMinute|NSCalendarUnitHour fromDate:[NSDate date]];</span><br><span class="line">    NSDate *sendDate = [NSDate dateWithTimeIntervalSinceNow:0];</span><br><span class="line">    </span><br><span class="line">    //查询条件 (10天 * 24小时 )</span><br><span class="line">    NSDate *sstartDate = [NSDate dateWithTimeIntervalSinceNow:-(currentCompents.hour * 3600 + currentCompents.minute * 60 + currentCompents.second)];</span><br><span class="line">    NSPredicate *spredicate = [HKQuery predicateForSamplesWithStartDate:sstartDate endDate:sendDate options:HKQueryOptionStrictStartDate];</span><br><span class="line">    </span><br><span class="line">    [self executeStatisticsQueryForQuantityType:stepType predicate:spredicate anchorDate:sendDate intervalComponents:intervalCompents callBackResult:^(HKStatistics * _Nullable result, NSError *error) &#123;</span><br><span class="line">        if (resultBlock) &#123;</span><br><span class="line">            resultBlock(@[result], error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//统计数据</span><br><span class="line">- (void)executeStatisticsQueryForQuantityType:(HKQuantityType *)quantityType</span><br><span class="line">                          predicate:(nullable NSPredicate *)quantitySamplePredicate</span><br><span class="line">                         anchorDate:(NSDate *)anchorDate</span><br><span class="line">                 intervalComponents:(NSDateComponents *)intervalComponents</span><br><span class="line">                     callBackResult:(void (^)(HKStatistics * __nullable result, NSError *error))queryResult</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    HKStatisticsQuery *statisticQuery =</span><br><span class="line">    [[HKStatisticsQuery alloc]initWithQuantityType:quantityType quantitySamplePredicate:quantitySamplePredicate options:HKStatisticsOptionCumulativeSum completionHandler:^(HKStatisticsQuery * _Nonnull query, HKStatistics * _Nullable result, NSError * _Nullable error) &#123;</span><br><span class="line">        if (queryResult) &#123;</span><br><span class="line">            queryResult(result, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.healthStore executeQuery:statisticQuery];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询指定日期时间段内的数据,此处为前10日</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">//查询指定日期时间段的数据(前10日)</span><br><span class="line">- (void)fetchAllHealthDataByDay:(void(^)(NSArray *dataArray))resultBlock</span><br><span class="line">&#123;</span><br><span class="line">    HKQuantityType *quantityType = [HKQuantityType quantityTypeForIdentifier:HKQuantityTypeIdentifierStepCount];</span><br><span class="line">    </span><br><span class="line">    //查询数据的时间间隔</span><br><span class="line">    NSDateComponents *intervalCompents = [[NSDateComponents alloc]init];</span><br><span class="line">    intervalCompents.day = 1;</span><br><span class="line">    </span><br><span class="line">    //查询数据的开始时间(锚点 anchordate)</span><br><span class="line">    //1.获取日历</span><br><span class="line">    NSCalendar *calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">    </span><br><span class="line">    //2.当前时间组件</span><br><span class="line">    NSDateComponents *currentCompents = [calendar components:NSCalendarUnitSecond|NSCalendarUnitMinute|NSCalendarUnitHour fromDate:[NSDate date]];</span><br><span class="line">    NSDate *endDate = [NSDate dateWithTimeIntervalSinceNow:-(currentCompents.hour * 3600 + currentCompents.minute * 60 + currentCompents.second)];</span><br><span class="line">    </span><br><span class="line">    //查询条件 (10天 * 24小时 )</span><br><span class="line">    NSDate *startDate = [NSDate dateWithTimeIntervalSinceNow:-(currentCompents.hour * 3600 + currentCompents.minute * 60 + currentCompents.second + 10 * 24 * 3600)];</span><br><span class="line">    NSPredicate *predicate = [HKQuery predicateForSamplesWithStartDate:startDate endDate:endDate options:HKQueryOptionStrictStartDate];</span><br><span class="line">    //TODO:0805---待修改</span><br><span class="line">        [self executeQueryForQuantityType:quantityType</span><br><span class="line">                                predicate:predicate</span><br><span class="line">                               anchorDate:endDate</span><br><span class="line">                       intervalComponents:intervalCompents</span><br><span class="line">                           callBackResult:^(HKStatisticsCollection * _Nullable result, NSError *error) &#123;</span><br><span class="line">                               </span><br><span class="line">                               __block NSMutableArray *tempArray = @[].mutableCopy;</span><br><span class="line">                               [result.statistics enumerateObjectsUsingBlock:^(HKStatistics * _Nonnull statistics,</span><br><span class="line">                                                                               NSUInteger idx, BOOL * _Nonnull statisticsStop) &#123;</span><br><span class="line">                                  /* [statistics.sources enumerateObjectsUsingBlock:^(HKSource * _Nonnull source,</span><br><span class="line">                                                                                    NSUInteger idx, BOOL * _Nonnull sourceStop) &#123;</span><br><span class="line">                                       </span><br><span class="line">                                      // double stepCount = [[statistics sumQuantityForSource:source] doubleValueForUnit:[HKUnit countUnit]];</span><br><span class="line">                                       </span><br><span class="line">                                        double stepCount = [[statistics sumQuantity] doubleValueForUnit:[HKUnit countUnit]];</span><br><span class="line">                                       NSDateFormatter *formatter = [[NSDateFormatter alloc]init];</span><br><span class="line">                                       [formatter setDateFormat:@&quot;yyyy-MM-dd&quot;];</span><br><span class="line">                                       </span><br><span class="line">                                       NSString *stringDate = [formatter stringFromDate:statistics.startDate];</span><br><span class="line">                                       //NSLog(@&quot;******** %f, %@&quot;,stepCount, stringDate);</span><br><span class="line">                                       </span><br><span class="line">                                       </span><br><span class="line">                                       NSDictionary *tempDictionary = [NSDictionary dictionaryWithObjectsAndKeys:stringDate, @&quot;date_time&quot;,@(stepCount),@&quot;step&quot;, nil];</span><br><span class="line">                                       </span><br><span class="line">                                       [tempArray insertObject:tempDictionary atIndex:0];</span><br><span class="line">                                       *sourceStop = YES;</span><br><span class="line">                                   &#125;];*/</span><br><span class="line">                                   </span><br><span class="line">                                   </span><br><span class="line">                                   double stepCount = [[statistics sumQuantity] doubleValueForUnit:[HKUnit countUnit]];</span><br><span class="line">                                   int step = (int)ceil(stepCount);</span><br><span class="line">                                   NSDateFormatter *formatter = [[NSDateFormatter alloc]init];</span><br><span class="line">                                   [formatter setDateFormat:@&quot;yyyy-MM-dd&quot;];</span><br><span class="line">                                   </span><br><span class="line">                                   NSString *stringDate = [formatter stringFromDate:statistics.startDate];</span><br><span class="line">                                   //NSLog(@&quot;******** %f, %@&quot;,stepCount, stringDate);</span><br><span class="line">                                   </span><br><span class="line">                                   </span><br><span class="line">                                   NSDictionary *tempDictionary = [NSDictionary dictionaryWithObjectsAndKeys:stringDate, @&quot;date_time&quot;,@(step),@&quot;step&quot;, nil];</span><br><span class="line">                                   </span><br><span class="line">                                   [tempArray insertObject:tempDictionary atIndex:0];</span><br><span class="line">                               &#125;];</span><br><span class="line">                               </span><br><span class="line">                               if (resultBlock) &#123;</span><br><span class="line">                                   resultBlock(tempArray);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//分类统计查询</span><br><span class="line">- (void)executeQueryForQuantityType:(HKQuantityType *)quantityType</span><br><span class="line">                          predicate:(nullable NSPredicate *)quantitySamplePredicate</span><br><span class="line">                         anchorDate:(NSDate *)anchorDate</span><br><span class="line">                 intervalComponents:(NSDateComponents *)intervalComponents</span><br><span class="line">                     callBackResult:(void (^)(HKStatisticsCollection * __nullable result, NSError *error))queryResult</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    HKStatisticsCollectionQuery *collectionQuery =</span><br><span class="line">    [[HKStatisticsCollectionQuery alloc] initWithQuantityType:quantityType</span><br><span class="line">                                      quantitySamplePredicate:quantitySamplePredicate</span><br><span class="line">                                                      options:HKStatisticsOptionCumulativeSum | HKStatisticsOptionSeparateBySource</span><br><span class="line">                                                   anchorDate:anchorDate</span><br><span class="line">                                           intervalComponents:intervalComponents];</span><br><span class="line">    </span><br><span class="line">    collectionQuery.initialResultsHandler = ^(HKStatisticsCollectionQuery *query, HKStatisticsCollection * __nullable result, NSError * __nullable error)&#123;</span><br><span class="line">        if (queryResult) &#123;</span><br><span class="line">            queryResult(result, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    [self.healthStore executeQuery:collectionQuery];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>这次使用HealthKit过程中使用到了三种query, 分别为<code>HKStatisticsCollectionQuery</code> , <code>HKStatisticsQuery</code>, <code>HKSampleQuery</code>, 不同的query返回的数据结果不同, 根据不同的场景,使用不同的查询方式. </li>
<li>HealthKit里面还有很多东西需要学习, 这次开发过程中遇到的问题理解的也不透彻,需要以后不断加强</li>
</ol>
<p><em>参考链接</em></p>
<ol>
<li>iOS 8 HealthKit 介绍 <a href="http://vit0.com/blog/2014/10/30/ios-8-healthkit-jie-shao/" target="_blank" rel="external">http://vit0.com/blog/2014/10/30/ios-8-healthkit-jie-shao/</a> </li>
<li>HealthKitDemo <a href="https://github.com/MarsCWD/HealthKitDemo" target="_blank" rel="external">https://github.com/MarsCWD/HealthKitDemo</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/05/HealthKit-使用笔记-一/" data-id="cizgqoijz0001uoux8csfndmr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-绘制尾部带有圆圈的圆环" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/02/绘制尾部带有圆圈的圆环/" class="article-date">
  <time datetime="2016-08-02T10:49:58.000Z" itemprop="datePublished">2016-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/02/绘制尾部带有圆圈的圆环/">绘制尾部带有圆圈的圆环</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#绘制尾部带有圆圈的圆环</p>
<h2 id="UI设计稿如下"><a href="#UI设计稿如下" class="headerlink" title="UI设计稿如下"></a>UI设计稿如下</h2><p><img src="/img/1.png" alt="屏幕快照 2016-08-02 17.37.42-w640"></p>
<h2 id="知识关键点"><a href="#知识关键点" class="headerlink" title="知识关键点"></a>知识关键点</h2><ul>
<li>用<code>CAShapeLayer</code>绘制圆环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (CAShapeLayer *)shaperLayerRadius:(CGFloat)radius</span><br><span class="line">                    fillColor:(UIColor *)fillColor</span><br><span class="line">                  strokeColor:(UIColor *)strokeColor</span><br><span class="line">                           endAngle:(CGFloat)endAngle</span><br><span class="line">&#123;</span><br><span class="line">    CGFloat centerX = self.backGroundView.frame.size.width / 2.0;</span><br><span class="line">    CGFloat centerY = self.backGroundView.frame.size.height / 2.0;</span><br><span class="line">    </span><br><span class="line">    UIBezierPath *path =</span><br><span class="line">    [UIBezierPath bezierPathWithArcCenter:CGPointMake(centerX, centerY)</span><br><span class="line">                                radius:radius</span><br><span class="line">                            startAngle:M_PI * (-90) / 180.0</span><br><span class="line">                              endAngle:M_PI * (endAngle) / 180.0</span><br><span class="line">                             clockwise:YES];</span><br><span class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</span><br><span class="line">    layer.path = path.CGPath;</span><br><span class="line">    layer.fillColor = fillColor.CGColor;</span><br><span class="line">    layer.strokeColor = strokeColor.CGColor;</span><br><span class="line">    layer.lineWidth = 10.0;</span><br><span class="line">    layer.frame = self.backGroundView.bounds;</span><br><span class="line">    return layer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CABasicAnimation</code>完成圆环绘制动画,以下代码中,需要绘制的layer为<code>self.bodyFatLayer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:NSStringFromSelector(@selector(strokeEnd))];</span><br><span class="line">pathAnimation.duration = 5.0;</span><br><span class="line">pathAnimation.fromValue = @0;</span><br><span class="line">pathAnimation.toValue = @1;</span><br><span class="line">[self.bodyFatLayer addAnimation:pathAnimation forKey:NSStringFromSelector(@selector(strokeEnd))];</span><br></pre></td></tr></table></figure>
<ul>
<li>计算尾部圆环的位置公式为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">圆点坐标：(x0,y0)</span><br><span class="line">    </span><br><span class="line">半径：r</span><br><span class="line">角度：a0</span><br><span class="line">    </span><br><span class="line">则圆上任一点为：（x1,y1）</span><br><span class="line">x1   =   x0   +   r   *   cos(ao   *   3.14   /180   )</span><br><span class="line">y1   =   y0   +   r   *   sin(ao   *   3.14   /180   )</span><br></pre></td></tr></table></figure>
<ul>
<li>动画开始之前计算<code>self.bodyFatValueLayer</code>在view中的位置,并添加动画</li>
<li><code>CAKeyframeAnimation</code> 完成尾部圆环的动画,其中动画所需要的<code>path</code>由圆环<code>self.bodyFatLayer</code>的<code>path</code>决定.以下代码中需要沿着圆环轨迹运动的<code>layer</code>为<code>self.bodyFatValueLayer</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">penAnimation.duration = 5.0;</span><br><span class="line">penAnimation.path = self.bodyFatLayer.path;</span><br><span class="line">penAnimation.calculationMode = kCAAnimationPaced;</span><br><span class="line">[self.bodyFatValueLayer addAnimation:penAnimation forKey:@&quot;penAnimation&quot;];</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/08/02/绘制尾部带有圆圈的圆环/" data-id="cizgqoiny001buouxpmf7rzg0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/22/为什么争执/">为什么争执</a>
          </li>
        
          <li>
            <a href="/2017/02/21/一场大雪/">一场大雪</a>
          </li>
        
          <li>
            <a href="/2017/02/20/裸奔下海/">裸奔下海</a>
          </li>
        
          <li>
            <a href="/2017/02/19/布朗熊水杯/">布朗熊水杯</a>
          </li>
        
          <li>
            <a href="/2017/02/17/终于完成了一件大事/">终于完成了一件大事</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Summer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>